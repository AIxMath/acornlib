from util import constant
from nat import Nat
from rat import Rat
from list import partials, sum, map, List, range
import real_set
from real_ring import Real, converges, converges_to, limit, cauchy_bound, tail_bound

// This file defines infinite series and proves theorems about them.

class Real {
    // Placeholder to let other modules import Real from here.
}

// seq_lte is whether every element of the sequence is lte.
define seq_lte(a: Nat -> Real, b: Nat -> Real) -> Bool {
    forall(n: Nat) {
        a(n) <= b(n)
    }
}

theorem partials_suc(a: Nat -> Real, n: Nat) {
    partials(a, n.suc) = partials(a, n) + a(n)
} by {
    // Simplify the left hand side.
    partials(a, n.suc) = sum(map(List.range(n.suc), a))
    List.range(n.suc) = List.range(n) + List.singleton(n)
    map(List.range(n.suc), a) = map(List.range(n), a) + map(List.singleton(n), a)
    sum(map(List.range(n.suc), a)) = sum(map(List.range(n), a)) + sum(map(List.singleton(n), a))
}

// Theorem: If seq_lte(a, b), then their partials also obey seq_lte.
theorem partials_seq_lte(a: Nat -> Real, b: Nat -> Real) {
    seq_lte(a, b) implies seq_lte(partials(a), partials(b))
} by {
    // Define a predicate for our induction
    define p(n: Nat) -> Bool {
        partials(a)(n) <= partials(b)(n)
    }

    partials(a)(Nat.0) <= partials(b)(Nat.0)
    p(Nat.0)

    // Inductive step
    forall(n: Nat) {
        if p(n) {
            partials(a, n) <= partials(b, n)
            a(n) <= b(n)
            partials(a, n) + a(n) <= partials(b, n) + a(n)
            partials(a, n) + a(n) <= partials(b, n) + b(n)
            partials(a)(n.suc) <= partials(b)(n.suc)
            p(n.suc)
        }
    }

    // By induction, p holds for all n
    forall(n: Nat) {
        p(n)
    }
}

// This definition of increasing is not strict.
// It includes less-than-or-equal.
define is_increasing(a: Nat -> Real) -> Bool {
    forall(n: Nat) {
        a(n) <= a(n.suc)
    }
}

theorem distant_increasing(a: Nat -> Real, m: Nat, n: Nat) {
    is_increasing(a) and m <= n implies a(m) <= a(n)
} by {
    // Define a predicate for our induction
    define p(k: Nat) -> Bool {
        forall(j: Nat) {
            j + k <= n implies a(j) <= a(j + k)
        }
    }

    // Base case: k = 0
    forall(j: Nat) {
        if j + Nat.0 <= n {
            j <= n
            j + Nat.0 = j
            a(j) <= a(j)
        }
    }
    p(Nat.0)

    // Inductive step: if p(k) holds, prove p(k.suc)
    forall(k: Nat) {
        if p(k) {
            forall(j: Nat) {
                if j + k.suc <= n {
                    // This means j+k+1 <= n, which means j+k <= n-1 < n
                    j + k <= n

                    // Apply p(k) to get a(j) <= a(j+k)
                    a(j) <= a(j + k)

                    // Apply the definition of is_increasing to the point j+k
                    a(j + k) <= a(j + k + Nat.1)
                    a(j + k) <= a(j + k.suc)

                    // Combine the inequalities
                    a(j) <= a(j + k.suc)
                }
            }
            p(k.suc)
        }
    }

    // Apply the predicate with j=m, k=n-m
    if m <= n {
        let k: Nat satisfy { m + k = n }
        p(k)
        m + k <= n
        a(m) <= a(m + k)
        a(m) <= a(n)
    }
}

define is_upper_bound(a: Nat -> Real, b: Real) -> Bool {
    forall(n: Nat) {
        a(n) <= b
    }
}

define is_least_upper_bound(a: Nat -> Real, l: Real) -> Bool {
    is_upper_bound(a, l) and forall(x: Real) {
        x < l implies not is_upper_bound(a, x)
    }
}

define is_lower_bound(a: Nat -> Real, b: Real) -> Bool {
    forall(n: Nat) {
        b <= a(n)
    }
}

// Theorem: If a sequence is increasing and converges, then its limit is an upper bound
theorem increasing_convergent_bounded_by_limit(a: Nat -> Real) {
    is_increasing(a) and converges(a)
    implies is_upper_bound(a, limit(a))
} by {
    // We'll prove that for any n, a(n) <= limit(a)
    forall(n: Nat) {
        // Suppose for contradiction that a(n) > limit(a)
        if a(n) > limit(a) {
            // Find a value that's between limit(a) and a(n)
            let ub: Real satisfy {
                limit(a) < ub and ub < a(n)
            } 

            // Since the sequence converges to limit(a), there must be a point
            // after which all sequence values are < ub
            let eps: Real = ub - limit(a)
            eps.is_positive

            // By the definition of convergence, find a point where the sequence
            // is within eps of the limit for all indices beyond that point
            let (big_n: Nat) satisfy {
                forall(i: Nat) {
                    big_n <= i implies a(i).is_close(limit(a), eps)
                }
            }

            // Since a(n) > ub, we know n can't be >= big_n (or a(n) would be within eps of limit(a))
            // So either n < big_n or we have a contradiction
            // Case 1: n < big_n
            if n < big_n {
                // Since sequence is increasing, a(n) <= a(big_n)
                a(n) <= a(big_n)

                // But since a(big_n) is within eps of limit(a), we have a(big_n) < ub
                a(big_n).is_close(limit(a), eps)
                // Being close means the absolute difference is < eps
                (a(big_n) - limit(a)).abs < eps
                // For real numbers, if they're close and one is less than another plus epsilon
                // then the first is less than the second plus epsilon
                a(big_n) < limit(a) + eps
                // And since eps = ub - limit(a), we have limit(a) + eps = ub
                limit(a) + eps = ub
                a(big_n) < ub

                // So a(n) <= a(big_n) < ub, contradicting our assumption that a(n) > ub
                a(n) < ub
                false
            } else {
                // Case 2: n >= big_n
                // Then a(n) is within eps of limit(a)
                a(n).is_close(limit(a), eps)
                // Being close means the absolute difference is < eps
                (a(n) - limit(a)).abs < eps
                // For real numbers, if they're close and one is less than another plus epsilon
                // then the first is less than the second plus epsilon
                a(n) < limit(a) + eps
                // And since eps = ub - limit(a), we have limit(a) + eps = ub
                limit(a) + eps = ub
                a(n) < ub

                // Contradicting our assumption that a(n) > ub
                false
            }

            // Either way, we get a contradiction, so a(n) <= limit(a)
        }

        // Therefore, a(n) <= limit(a)
        a(n) <= limit(a)
    }
}

define image(a: Nat -> Real, x: Real) -> Bool {
    exists(n: Nat) {
        a(n) = x
    }
}

theorem ub_imp_image_ub(a: Nat -> Real, b: Real) {
    is_upper_bound(a, b)
    implies real_set.is_upper_bound(image(a), b)
}

// If there's an upper bound, there's a least upper bound.
theorem ub_imp_lub(a: Nat -> Real, b: Real) {
    is_upper_bound(a, b) implies exists(c: Real) {
        is_least_upper_bound(a, c)
    }
} by {
    real_set.is_upper_bound(image(a), b)
    let c: Real satisfy {
        real_set.is_least_upper_bound(image(a), c)
    }
    is_upper_bound(a, c)
    forall(x: Real) {
        if x < c {
            if is_upper_bound(a, x) {
                real_set.is_upper_bound(image(a), x)
                false
            }
        }
    }
    is_least_upper_bound(a, c)
}

// The monotone convergence principle states that any increasing sequence 
// that is bounded above converges
theorem monotone_convergence_principle(a: Nat -> Real, b: Real) {
    is_increasing(a) and is_upper_bound(a, b) implies converges(a)
} by {
    let l: Real satisfy {
        is_least_upper_bound(a, l)
    }
    
    forall(eps: Real) {
        if eps.is_positive {
            // Find epsilon/2 for triangle inequality
            let eps2: Real satisfy {
                eps2.is_positive and eps2 + eps2 < eps
            }
            
            // Since l is the least upper bound, l-eps2 is not an upper bound
            let x: Real = l - eps2
            x < l
            not is_upper_bound(a, x)
            
            // If x is not an upper bound, there exists some n such that a(n) > x
            let n: Nat satisfy {
                not a(n) <= x
            }
            // We know a(n) > x = l - eps2
            l - eps2 < a(n)
            
            // For all indices i,j ≥ n, prove they're within epsilon of each other
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    n <= i
                    a(n) <= a(i)
                    n <= j
                    a(n) <= a(j)
                    a(i) <= l
                    a(j) <= l
                    l - eps2 < a(n)
                    l - eps2 < a(i)
                    l - eps2 < a(j)
                    a(i) < l + eps2
                    (l - a(i)).abs < eps2
                    (a(i) - l).abs < eps2
                    l - eps2 < a(j)
                    a(j) <= l
                    a(j) < l + eps2
                    (a(j) - l).abs < eps2
                    (a(i) - a(j)).abs < eps2 + eps2
                    eps2 + eps2 < eps
                    (a(i) - a(j)).abs < eps
                    a(i).is_close(a(j), eps)
                }
            }
            
            // We've proven that for all i,j ≥ n,
            // a(i) and a(j) are within epsilon of each other.
            // This is exactly the definition of cauchy_condition
            cauchy_bound(a, n, eps)
        }
    }
}

theorem nonneg_partials_increasing(a: Nat -> Real) {
    is_lower_bound(a, Real.0) implies is_increasing(partials(a))
}

theorem nonneg_partials_bounded_above(a: Nat -> Real) {
    is_lower_bound(a, Real.0) and converges(partials(a))
    implies is_upper_bound(partials(a), limit(partials(a)))
} by {
    is_increasing(partials(a))
}

theorem seq_lte_ub(a: Nat -> Real, b: Nat -> Real, ub: Real) {
    seq_lte(a, b) and is_upper_bound(b, ub)
    implies is_upper_bound(a, ub)
}

theorem comparison_test(a: Nat -> Real, b: Nat -> Real) {
    is_lower_bound(a, Real.0)
    and seq_lte(a, b)
    and converges(partials(b))
    implies converges(partials(a))
} by { 
    is_lower_bound(b, Real.0)  
    seq_lte(partials(a), partials(b))
    is_upper_bound(partials(b), limit(partials(b)))
    is_upper_bound(partials(a), limit(partials(b)))
}

define mul_seq(a: Real, b: Nat -> Real, n: Nat) -> Real {
    a * b(n)
}

theorem const_converges(a: Real) {
    converges(constant<Nat, Real>(a))
}

theorem const_limit(a: Real) {
    limit(constant<Nat, Real>(a)) = a
}

theorem const_converges_to(a: Real) {
    converges_to(constant<Nat, Real>(a), a)
}

theorem mul_seq_zero(a: Nat -> Real) {
    mul_seq(Real.0, a) = constant<Nat, Real>(Real.0)
}

// theorem mul_seq_converges_to_(a: Real, b: Nat -> Real) {
//     converges(b) implies converges_to(mul_seq(a, b), a * limit(b))
// } by {
//     converges_to(b, limit(b))
//     forall(eps: Real) {
//         if eps.is_positive {
//             let eps2: Real satisfy {
//                 eps2.is_positive and eps2 * a.abs < eps
//             }
//             let n: Nat satisfy {
//                 tail_bound(b, limit(b), n, eps2)
//             }
//             tail_bound(mul_seq(a, b), a * limit(b), n, eps)
//         }
//     }
// }

theorem converges_pos_mul_seq(a: Real, b: Nat -> Real) {
    a.is_positive and converges(b)
    implies converges(mul_seq(a, b))
} by {
    not a.is_negative
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and a * eps2 < eps
            }
            
            let n: Nat satisfy {
                cauchy_bound(b, n, eps2)
            }
            
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    b(i).is_close(b(j), eps2)
                    (b(i) - b(j)).abs < eps2
                    a * (b(i) - b(j)).abs < a * eps2
                    a.abs * (b(i) - b(j)).abs < a * eps2
                    (a * (b(i) - b(j))).abs < a * eps2
                    (a * b(i) - a * b(j)).abs < a * eps2
                    mul_seq(a, b)(i).is_close(mul_seq(a, b)(j), eps)
                }
            }
            
            cauchy_bound(mul_seq(a, b), n, eps)
        }
    }
}

theorem neg_seq_converges(a: Nat -> Real) {
    converges(a) implies converges(mul_seq(-Real.1, a))
} by {
    let nsa: Nat -> Real = mul_seq(-Real.1, a)
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and eps2 < eps
            }
            
            let n: Nat satisfy {
                cauchy_bound(a, n, eps2)
            }
            
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    a(i).is_close(a(j), eps2)
                    (a(i) - a(j)).abs < eps2
                    (-a(i) - -a(j)).abs < eps2
                    nsa(i).is_close(nsa(j), eps)
                }
            }
            
            cauchy_bound(nsa, n, eps)
        }
    }
    converges(nsa)
}

theorem mul_seq_one(a: Nat -> Real) {
    mul_seq(Real.1, a) = a
}

theorem neg_seq_converges_converse(a: Nat -> Real) {
    converges(mul_seq(-Real.1, a)) implies converges(a)
} by {
    converges(mul_seq(-Real.1, mul_seq(-Real.1, a)))
    mul_seq(-Real.1, mul_seq(-Real.1, a)) = mul_seq((-Real.1) * -Real.1, a)
    converges(mul_seq((-Real.1) * -Real.1, a))
    -Real.1 * -Real.1 = Real.1
    converges(mul_seq(Real.1, a))
    mul_seq(Real.1, a) = a
}

theorem mul_seq_comm(a: Real, b: Real, c: Nat -> Real) {
    mul_seq(a, mul_seq(b, c)) = mul_seq(b, mul_seq(a, c))
}

theorem mul_seq_combine(a: Real, b: Real, c: Nat -> Real) {
    mul_seq(a * b, c) = mul_seq(a, mul_seq(b, c))
}

theorem converges_neg_mul_seq(a: Real, b: Nat -> Real) {
    a.is_negative and converges(b)
    implies converges(mul_seq(a, b))
} by {
    (-a).is_positive
    converges(mul_seq(-a, b))
    mul_seq(-a, b) = mul_seq(-Real.1 * a, b)
    mul_seq(-a, b) = mul_seq(-Real.1, mul_seq(a, b))
}

theorem converges_mul_seq(a: Real, b: Nat -> Real) {
    converges(b) implies converges(mul_seq(a, b))
} by {
    if a.is_positive {
        converges(mul_seq(a, b))
    } else {
        if a = Real.0 {
            mul_seq(Real.0, b) = constant<Nat, Real>(Real.0)
            converges(mul_seq(a, b))
        } else {
            converges(mul_seq(a, b))
        }
    }
}