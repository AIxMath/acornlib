from nat import Nat
from rat import Rat
from list import partials, sum, map, List, range
from real_ring import Real, converges, converges_to, limit

// This file defines infinite series and proves theorems about them.

class Real {
    // Placeholder to let other modules import Real from here.
}

// seq_lte is whether every element of the sequence is lte.
define seq_lte(a: Nat -> Real, b: Nat -> Real) -> Bool {
    forall(n: Nat) {
        a(n) <= b(n)
    }
}

theorem partials_suc(a: Nat -> Real, n: Nat) {
    partials(a, n.suc) = partials(a, n) + a(n)
} by {
    // Simplify the left hand side.
    partials(a, n.suc) = sum(map(List.range(n.suc), a))
    List.range(n.suc) = List.range(n) + List.singleton(n)
    map(List.range(n.suc), a) = map(List.range(n), a) + map(List.singleton(n), a)
    sum(map(List.range(n.suc), a)) = sum(map(List.range(n), a)) + sum(map(List.singleton(n), a))
}

// Theorem: If seq_lte(a, b), then their partials also obey seq_lte.
theorem partials_seq_lte(a: Nat -> Real, b: Nat -> Real) {
    seq_lte(a, b) implies seq_lte(partials(a), partials(b))
} by {
    // Define a predicate for our induction
    define p(n: Nat) -> Bool {
        partials(a)(n) <= partials(b)(n)
    }

    partials(a)(Nat.0) <= partials(b)(Nat.0)
    p(Nat.0)

    // Inductive step
    forall(n: Nat) {
        if p(n) {
            partials(a, n) <= partials(b, n)
            a(n) <= b(n)
            partials(a, n) + a(n) <= partials(b, n) + a(n)
            partials(a, n) + a(n) <= partials(b, n) + b(n)
            partials(a)(n.suc) <= partials(b)(n.suc)
            p(n.suc)
        }
    }

    // By induction, p holds for all n
    forall(n: Nat) {
        p(n)
    }
}

// This definition of increasing is not strict.
// It includes less-than-or-equal.
define is_increasing(a: Nat -> Real) -> Bool {
    forall(n: Nat) {
        a(n) <= a(n.suc)
    }
}

theorem distant_increasing(a: Nat -> Real, m: Nat, n: Nat) {
    is_increasing(a) and m <= n implies a(m) <= a(n)
} by {
    // Define a predicate for our induction
    define p(k: Nat) -> Bool {
        forall(j: Nat) {
            j + k <= n implies a(j) <= a(j + k)
        }
    }

    // Base case: k = 0
    forall(j: Nat) {
        if j + Nat.0 <= n {
            j <= n
            j + Nat.0 = j
            a(j) <= a(j)
        }
    }
    p(Nat.0)

    // Inductive step: if p(k) holds, prove p(k.suc)
    forall(k: Nat) {
        if p(k) {
            forall(j: Nat) {
                if j + k.suc <= n {
                    // This means j+k+1 <= n, which means j+k <= n-1 < n
                    j + k <= n

                    // Apply p(k) to get a(j) <= a(j+k)
                    a(j) <= a(j + k)

                    // Apply the definition of is_increasing to the point j+k
                    a(j + k) <= a(j + k + Nat.1)
                    a(j + k) <= a(j + k.suc)

                    // Combine the inequalities
                    a(j) <= a(j + k.suc)
                }
            }
            p(k.suc)
        }
    }

    // Apply the predicate with j=m, k=n-m
    if m <= n {
        let k: Nat satisfy { m + k = n }
        p(k)
        m + k <= n
        a(m) <= a(m + k)
        a(m) <= a(n)
    }
}