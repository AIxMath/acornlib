import nat
from int import Int, abs, gcd

numerals Int

define is_reduced(a: Int, b: Int) -> Bool {
    b > 0 and gcd(a, b) = 1
}

theorem denom_one_is_reduced(a: Int) {
    is_reduced(a, 1)
}

structure Rat {
    num: Int
    denom: Int
} constraint {
    is_reduced(num, denom)
}

class Rat {
    let 0: Rat = Rat.new(0, 1)
}

theorem zero_num {
    Rat.0.num = 0
}

theorem zero_denom {
    Rat.0.denom = 1
}

theorem denom_nonzero(r: Rat) {
    r.denom != 0
} by {
    r.denom > 0
}

theorem denom_positive(r: Rat) {
    r.denom.is_positive
} by {
    r.denom > 0
}

class Rat {
    let from_int: Int -> Rat = function(n: Int) {
        Rat.new(n, 1)
    }
}

theorem from_int_num(n: Int) {
    Rat.from_int(n).num = n
}

theorem from_int_denom(n: Int) {
    Rat.from_int(n).denom = 1
}

define cross_equals(a: Int, b: Int, c: Int, d: Int) -> Bool {
    b != 0 and d != 0 and a * d = c * b
}

theorem cross_equals_trans(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {
    cross_equals(a, b, c, d) and cross_equals(c, d, e, f) -> cross_equals(a, b, e, f)
} by {
    a * d = b * c
    c * f = d * e
    a * d * f = b * c * f
    a * d * f = b * d * e
    a * f * d = b * e * d
    d != 0
    a * f = b * e
}

// Either zero, or a / b reduced to simplest form.
let reduce(a: Int, b: Int) -> r: Rat satisfy {
    if b = 0 {
        r = Rat.0
    } else {
        cross_equals(r.num, r.denom, a, b)
    }
} by {
    if b = 0 {
        Rat.0 = Rat.0
    } else {
        // Factor out the gcd
        gcd(a, b) != 0
        let a1: Int satisfy {
            a1 * gcd(a, b) = a
        }
        let b1: Int satisfy {
            b1 * gcd(a, b) = b
        }
        b1 != 0
        a * b = a * b1 * gcd(a, b)
        a * b = b * a1 * gcd(a, b)
        a * b1 * gcd(a, b) = b * a1 * gcd(a, b)
        a * b1 = b * a1
        cross_equals(a1, b1, a, b)
        gcd(a1, b1) = 1

        // To reduce we also need to swap signs if the denominator is negative
        let a2: Int = a1 * int.unit_sign(b1)
        let b2: Int = b1 * int.unit_sign(b1)
        b2 = Int.from_nat(abs(b1))
        b2 != 0
        (a1 * int.unit_sign(b1)) * b1 = (b1 * int.unit_sign(b1)) * a1
        cross_equals(a2, b2, a1, b1)
        gcd(a2, b2) = 1 * Int.from_nat(abs(int.unit_sign(b1)))
        Int.from_nat(abs(int.unit_sign(b1))) = 1
        gcd(a2, b2) = 1
        b2 != 0
        is_reduced(a2, b2)

        let r: Rat = Rat.new(a2, b2)
        r.num = a2
        r.denom = b2
        cross_equals(r.num, r.denom, a2, b2)
        cross_equals(a2, b2, a, b)
        cross_equals(r.num, r.denom, a, b)
    }
}

theorem cross_eq_imp_eq(r1: Rat, r2: Rat) {
    cross_equals(r1.num, r1.denom, r2.num, r2.denom) -> r1 = r2
} by {
    // The r1 fields divide into the r2 ones
    gcd(r1.num, r1.denom) = 1
    int.divides(r1.denom, r1.num * r2.denom)
    int.divides(r1.denom, r2.denom)
    nat.divides(abs(r1.denom), abs(r2.denom))

    // The r2 fields divide into the r1 ones
    gcd(r2.num, r2.denom) = 1
    int.divides(r2.denom, r2.num * r1.denom)
    int.divides(r2.denom, r1.denom)
    nat.divides(abs(r2.denom), abs(r1.denom))

    // Prove int equality from nat equality
    abs(r1.denom) = abs(r2.denom)
    r1.denom.is_positive
    r2.denom.is_positive
    r1.denom = r2.denom

    // Divide out the denominators
    r1.num * r2.denom = r2.num * r1.denom
    r1.num * r2.denom = r2.num * r2.denom
    r2.denom != 0
    r1.num = r2.num
}

class Rat {
    let 1: Rat = Rat.new(1, 1)

    define is_positive(self) -> Bool {
        self.num.is_positive
    }

    define is_negative(self) -> Bool {
        self.num.is_negative
    }

    define neg(self) -> Rat {
        Rat.new(-self.num, self.denom)
    }

    define add(self, other: Rat) -> Rat {
        reduce(self.num * other.denom + other.num * self.denom,
               self.denom * other.denom)
    }

    define sub(self, other: Rat) -> Rat {
        self + -other
    }

    define mul(self, other: Rat) -> Rat {
        reduce(self.num * other.num, self.denom * other.denom)
    }

    // This is the weird version where dividing by zero gives you zero
    define div(self, other: Rat) -> Rat {
        reduce(self.num * other.denom, self.denom * other.num)
    }

    define lt(self, other: Rat) -> Bool {
        self.num * other.denom < other.num * self.denom
    }

    define lte(self, other: Rat) -> Bool {
        self < other or self = other
    }

    define gt(self, other: Rat) -> Bool {
        other < self
    }

    define gte(self, other: Rat) -> Bool {
        other <= self
    }
}

theorem reduce_idempotent(r: Rat) {
    reduce(r.num, r.denom) = r
}

theorem neg_is_reduced(r: Rat) {
    is_reduced(-r.num, r.denom)
} by {
    r.denom > 0
    gcd(-r.num, r.denom) = gcd(r.num, r.denom)
}

theorem neg_num(r: Rat) {
    r.neg.num = -r.num
}

theorem neg_denom(r: Rat) {
    r.neg.denom = r.denom
}

theorem add_zero_right(a: Rat) {
    a + Rat.0 = a
} by {
    a + Rat.0 = reduce(a.num * 1 + 0 * a.denom, a.denom * 1)
    a + Rat.0 = reduce(a.num, a.denom)
}

theorem add_zero_left(a: Rat) {
    Rat.0 + a = a
}

theorem add_comm(a: Rat, b: Rat) {
    a + b = b + a
}

theorem from_int_cancel(a: Int, b: Int) {
    Rat.from_int(a) = Rat.from_int(b) -> a = b
}

theorem mul_comm(a: Rat, b: Rat) {
    a * b = b * a
}

theorem rat_neg_one {
    -Rat.1 = Rat.from_int(-1)
} by {
    Rat.1 = Rat.new(1, 1)
    Rat.from_int(-1) = Rat.new(-1, 1)
}

theorem mul_neg_one_right(r: Rat) {
    r * -Rat.1 = -r
} by {
    r * Rat.from_int(-1) = -r
}

theorem mul_neg_one_left(r: Rat) {
    -Rat.1 * r = -r
}

theorem mul_one_right(r: Rat) {
    r * Rat.1 = r
} by {
    r * Rat.from_int(1) = r
}

theorem mul_one_left(r: Rat) {
    Rat.1 * r = r
}

// theorem mul_inverse_cancel_right(r: Rat) {
//     r != Rat.0 -> r * (1 / r) = Rat.from_int(1)
// }


// theorem reduce_cancel(a: Int, b: Int) {
//     a != 0 -> Rat.from_int(b) * reduce(a, b) = Rat.from_int(a)
// }

// theorem add_reduced_same_denom(a: Int, b: Int, c: Int) {
//     c != 0 -> reduce(a, c) + reduce(b, c) = reduce(a + b, c)
// }

// theorem add_reduced(a: Int, b: Int, c: Int, d: Int) {
//     b != 0 and d != 0 -> reduce(a, b) + reduce(c, d) = reduce(a * d + b * c, b * d)
// }

// theorem add_assoc(a: Rat, b: Rat, c: Rat) {
//     a + b + c = a + (b + c)
// }