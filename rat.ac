from nat import Nat
from nat_gcd import gcd
from int import Int, abs

numerals Int

structure Rat {
    num: Int
    denom: Nat
} constraint {
    gcd(abs(num), denom) = Nat.1
} by {
    gcd(abs(1), Nat.1) = Nat.1
}

class Rat {
    let 0: Rat = Rat.new(0, Nat.1)
}

theorem zero_num {
    Rat.0.num = 0
}

theorem zero_denom {
    Rat.0.denom = Nat.1
}

class Rat {
    let from_int: Int -> Rat = function(n: Int) {
        Rat.new(n, Nat.1)
    }
}

theorem from_int_num(n: Int) {
    Rat.from_int(n).num = n
}

theorem from_int_denom(n: Int) {
    Rat.from_int(n).denom = Nat.1
}

// Either zero, or a / b reduced to simplest form.
let reduce_nat(a: Nat, b: Nat) -> r: Rat satisfy {
    if b = Nat.0 {
        r = Rat.0
    } else {
        not int.is_negative(r.num) and abs(r.num) * b = r.denom * a
    }
} by {
    if b = Nat.0 {
        Rat.0 = Rat.0
    } else {
        // Factor out the gcd
        gcd(a, b) != Nat.0
        let a1: Nat satisfy {
            gcd(a, b) * a1 = a
        }
        let b1: Nat satisfy {
            gcd(a, b) * b1 = b
        }
        gcd(a1, b1) = Nat.1

        let r: Rat = Rat.new(Int.from_nat(a1), b1)
        r.num = Int.from_nat(a1)
        not int.is_negative(Int.from_nat(a1))
        not int.is_negative(r.num)
        r.denom = b1
        abs(r.num) = a1
        a1 * b = b1 * a
        not int.is_negative(r.num) and abs(r.num) * b = r.denom * a
    }
}