import nat
from int import Int, abs, gcd

numerals Int

define is_reduced(a: Int, b: Int) -> Bool {
    b > 0 and gcd(a, b) = 1
}

theorem denom_one_is_reduced(a: Int) {
    is_reduced(a, 1)
}

structure Rat {
    num: Int
    denom: Int
} constraint {
    is_reduced(num, denom)
}

class Rat {
    let 0: Rat = Rat.new(0, 1)
}

theorem zero_num {
    Rat.0.num = 0
}

theorem zero_denom {
    Rat.0.denom = 1
}

theorem denom_nonzero(r: Rat) {
    r.denom != 0
} by {
    r.denom > 0
}

theorem denom_positive(r: Rat) {
    r.denom.is_positive
} by {
    r.denom > 0
}

class Rat {
    let from_int: Int -> Rat = function(n: Int) {
        Rat.new(n, 1)
    }
}

theorem from_int_num(n: Int) {
    Rat.from_int(n).num = n
}

theorem from_int_denom(n: Int) {
    Rat.from_int(n).denom = 1
}

define cross_equals(a: Int, b: Int, c: Int, d: Int) -> Bool {
    b != 0 and d != 0 and a * d = c * b
}

theorem cross_equals_trans(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {
    cross_equals(a, b, c, d) and cross_equals(c, d, e, f) -> cross_equals(a, b, e, f)
} by {
    a * d = b * c
    c * f = d * e
    a * d * f = b * c * f
    a * d * f = b * d * e
    a * f * d = b * e * d
    d != 0
    a * f = b * e
}

// Either zero, or a / b reduced to simplest form.
let reduce(a: Int, b: Int) -> r: Rat satisfy {
    if b = 0 {
        r = Rat.0
    } else {
        cross_equals(r.num, r.denom, a, b)
    }
} by {
    if b = 0 {
        Rat.0 = Rat.0
    } else {
        // Factor out the gcd
        gcd(a, b) != 0
        let a1: Int satisfy {
            a1 * gcd(a, b) = a
        }
        let b1: Int satisfy {
            b1 * gcd(a, b) = b
        }
        b1 != 0
        a * b = a * b1 * gcd(a, b)
        a * b = b * a1 * gcd(a, b)
        a * b1 * gcd(a, b) = b * a1 * gcd(a, b)
        a * b1 = b * a1
        cross_equals(a1, b1, a, b)
        gcd(a1, b1) = 1

        // To reduce we also need to swap signs if the denominator is negative
        let a2: Int = a1 * int.unit_sign(b1)
        let b2: Int = b1 * int.unit_sign(b1)
        b2 = Int.from_nat(abs(b1))
        b2 != 0
        (a1 * int.unit_sign(b1)) * b1 = (b1 * int.unit_sign(b1)) * a1
        cross_equals(a2, b2, a1, b1)
        gcd(a2, b2) = 1 * Int.from_nat(abs(int.unit_sign(b1)))
        Int.from_nat(abs(int.unit_sign(b1))) = 1
        gcd(a2, b2) = 1
        b2 != 0
        is_reduced(a2, b2)

        let r: Rat = Rat.new(a2, b2)
        r.num = a2
        r.denom = b2
        cross_equals(r.num, r.denom, a2, b2)
        cross_equals(a2, b2, a, b)
        cross_equals(r.num, r.denom, a, b)
    }
}

theorem cross_eq_imp_eq(r1: Rat, r2: Rat) {
    cross_equals(r1.num, r1.denom, r2.num, r2.denom) -> r1 = r2
} by {
    // The r1 fields divide into the r2 ones
    gcd(r1.num, r1.denom) = 1
    int.divides(r1.denom, r1.num * r2.denom)
    int.divides(r1.denom, r2.denom)
    nat.divides(abs(r1.denom), abs(r2.denom))

    // The r2 fields divide into the r1 ones
    gcd(r2.num, r2.denom) = 1
    int.divides(r2.denom, r2.num * r1.denom)
    int.divides(r2.denom, r1.denom)
    nat.divides(abs(r2.denom), abs(r1.denom))

    // Prove int equality from nat equality
    abs(r1.denom) = abs(r2.denom)
    r1.denom.is_positive
    r2.denom.is_positive
    r1.denom = r2.denom

    // Divide out the denominators
    r1.num * r2.denom = r2.num * r1.denom
    r1.num * r2.denom = r2.num * r2.denom
    r2.denom != 0
    r1.num = r2.num
}

class Rat {
    define is_positive(self) -> Bool {
        self.num.is_positive
    }

    define is_negative(self) -> Bool {
        self.num.is_negative
    }

    define neg(self) -> Rat {
        Rat.new(-self.num, self.denom)
    }
}

theorem neg_is_reduced(r: Rat) {
    is_reduced(-r.num, r.denom)
} by {
    r.denom > 0
    gcd(-r.num, r.denom) = gcd(r.num, r.denom)
}

theorem neg_num(r: Rat) {
    r.neg.num = -r.num
}

theorem neg_denom(r: Rat) {
    r.neg.denom = r.denom
}