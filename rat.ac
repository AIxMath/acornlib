from int import Int, abs, gcd

numerals Int

define is_reduced(a: Int, b: Int) -> Bool {
    b > 0 and gcd(a, b) = 1
}

theorem denom_one_is_reduced(a: Int) {
    is_reduced(a, 1)
}

structure Rat {
    num: Int
    denom: Int
} constraint {
    is_reduced(num, denom)
}

class Rat {
    let 0: Rat = Rat.new(0, 1)
}

theorem zero_num {
    Rat.0.num = 0
}

theorem zero_denom {
    Rat.0.denom = 1
}

theorem denom_nonzero(r: Rat) {
    r.denom != 0
} by {
    r.denom > 0
}

class Rat {
    let from_int: Int -> Rat = function(n: Int) {
        Rat.new(n, 1)
    }
}

theorem from_int_num(n: Int) {
    Rat.from_int(n).num = n
}

theorem from_int_denom(n: Int) {
    Rat.from_int(n).denom = 1
}

define cross_equals(a: Int, b: Int, c: Int, d: Int) -> Bool {
    b != 0 and d != 0 and a * d = c * b
}

theorem cross_equals_trans(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {
    cross_equals(a, b, c, d) and cross_equals(c, d, e, f) -> cross_equals(a, b, e, f)
} by {
    a * d = b * c
    c * f = d * e
    a * d * f = b * c * f
    a * d * f = b * d * e
    a * f * d = b * e * d
    d != 0
    a * f = b * e
}

define rat_cross_equals(r: Rat, a: Int, b: Int) -> Bool {
    cross_equals(r.num, r.denom, a, b)
}

theorem rat_cross_equals_trans(r: Rat, a: Int, b: Int, c: Int, d: Int) {
    rat_cross_equals(r, a, b) and cross_equals(a, b, c, d) -> rat_cross_equals(r, c, d)
} by {
    cross_equals(r.num, r.denom, a, b)
    cross_equals(r.num, r.denom, c, d)
    cross_equals(a, b, c, d)
}

// Either zero, or a / b reduced to simplest form.
let reduce(a: Int, b: Int) -> r: Rat satisfy {
    if b = 0 {
        r = Rat.0
    } else {
        rat_cross_equals(r, a, b)
    }
} by {
    if b = 0 {
        Rat.0 = Rat.0
    } else {
        // Factor out the gcd
        gcd(a, b) != 0
        let a1: Int satisfy {
            a1 * gcd(a, b) = a
        }
        let b1: Int satisfy {
            b1 * gcd(a, b) = b
        }
        b1 != 0
        a * b = a * b1 * gcd(a, b)
        a * b = b * a1 * gcd(a, b)
        a * b1 * gcd(a, b) = b * a1 * gcd(a, b)
        a * b1 = b * a1
        cross_equals(a1, b1, a, b)
        gcd(a1, b1) = 1

        // To reduce we also need to swap signs if the denominator is negative
        let a2: Int = a1 * int.unit_sign(b1)
        let b2: Int = b1 * int.unit_sign(b1)
        b2 = Int.from_nat(abs(b1))
        b2 != 0
        (a1 * int.unit_sign(b1)) * b1 = (b1 * int.unit_sign(b1)) * a1
        cross_equals(a2, b2, a1, b1)
        gcd(a2, b2) = 1 * Int.from_nat(abs(int.unit_sign(b1)))
        Int.from_nat(abs(int.unit_sign(b1))) = 1
        gcd(a2, b2) = 1
        b2 != 0
        is_reduced(a2, b2)

        let r: Rat = Rat.new(a2, b2)
        r.num = a2
        r.denom = b2
        rat_cross_equals(r, a2, b2)
        cross_equals(a2, b2, a, b)
        rat_cross_equals(r, a, b)
    }
}