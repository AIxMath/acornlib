typeclass G: Group {
    // The identity
    e: G

    // The group operation
    mul: (G, G) -> G

    // The inverse operation
    inverse: G -> G

    // Groups must be associative
    associative(a: G, b: G, c: G) {
        (a * b) * c = a * (b * c)
    }
  
    // The identity element must satisfy the identity property
    identity_right(a: G) {
        a * G.e = a
    }
  
    // Other direction of the identity property
    identity_left(a: G) {
        G.e * a = a
    }

    // We only need right-inverse, we can prove left-inverse from it.
    inverse_right(a: G) {
        a * a.inverse = G.e
    }
}

// This direction is proven rather than assumed
theorem inverse_left<G: Group>(a: G) {
    a.inverse * a = G.e
} by {
    (a.inverse * a) * a.inverse = a.inverse
    (a.inverse * a) * a.inverse * a.inverse.inverse = a.inverse * a.inverse.inverse
    (a.inverse * a) * (a.inverse * a.inverse.inverse) = a.inverse * a.inverse.inverse
    (a.inverse * a) * G.e = G.e
}