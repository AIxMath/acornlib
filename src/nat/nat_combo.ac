from nat.nat_gcd import Nat

numerals Nat

// This file contains basic combinatorics.

// We want to define "n choose k", but it's a bit tricky to prove it's a natural number.
// We're going to do induction, but it'll be simpler to separate these out into named functions.
// We are essentially proving that n choose k is integral using the Pascal's triangle recurrence,
// except we are expressing the steps without using rational numbers.

define choose_exists(x: Nat, y: Nat) -> Bool {
    (x.factorial * y.factorial).divides((x + y).factorial)
}

// This will be the inductive hypothesis
define choose_hyp(n: Nat) -> Bool {
    forall(x: Nat, y: Nat) {
        if x + y = n {
            choose_exists(x, y)
        }
    }
}

theorem choose_exists_left_zero(x: Nat) {
    choose_exists(0, x)
}

theorem choose_exists_right_zero(x: Nat) {
    choose_exists(x, 0)
}

theorem choose_base {
    choose_hyp(0)
}

theorem choose_lemma(a: Nat, b: Nat) {
    a != 0 and b != 0 and choose_hyp(a + b - 1) implies
    (a.factorial * b.factorial).divides((a + b - 1).factorial * b)
} by {
    (a - 1) + 1 = a
    (b - 1) + 1 = b
    choose_hyp(a + (b - 1))

    // a! (b - 1)! divides (a + b - 1)!
    choose_exists(a, b - 1)
    a + b - 1 = a + (b - 1)
    (a.factorial * (b - 1).factorial).divides((a + b - 1).factorial)

    // a! b! (b - 1)! divides (a + b - 1)! b!
    (a.factorial * (b - 1).factorial * b.factorial).divides((a + b - 1).factorial * b.factorial)
    (a.factorial * b.factorial * (b - 1).factorial).divides((a + b - 1).factorial * b.factorial)
                        
    // a! b! (b - 1)! divides (a + b - 1)! b * (b - 1)!
    b.factorial = b * (b - 1).factorial
    (a.factorial * b.factorial * (b - 1).factorial).divides((a + b - 1).factorial * b * (b - 1).factorial)

    // a! b! divides (a + b - 1)! b
    (a.factorial * b.factorial).divides((a + b - 1).factorial * b)
}

theorem choose_exists_is_true(z1: Nat, z2: Nat) {
    choose_exists(z1, z2)
} by {
    forall(x: Nat) {
        if choose_hyp(x) {
            forall(a: Nat, b: Nat) {
                if a + b = x.suc {
                    if a = 0 {
                        choose_exists(a, b)
                    }
                    if b = 0 {
                        choose_exists(a, b)
                    }
                    if a != 0 and b != 0 {
                        // Use the lemma one way
                        (a.factorial * b.factorial).divides((a + b - 1).factorial * b)

                        // Use the lemma the other way
                        (b.factorial * a.factorial).divides((b + a - 1).factorial * a)
                        (a.factorial * b.factorial).divides((a + b - 1).factorial * a)

                        (a + b - 1).factorial * b + (a + b - 1).factorial * a = (a + b).factorial
                        (a.factorial * b.factorial).divides((a + b).factorial)
                        choose_exists(a, b)
                    }
                    choose_exists(a, b)
                }
            }
            choose_hyp(x.suc)
        }
    }

    choose_hyp(z1 + z2)
}

theorem choose_exists_sub_form(n: Nat, k: Nat) {
    k <= n implies exists(c: Nat) {
        c * k.factorial * (n - k).factorial = n.factorial
    }
} by {
    (n - k) + k = n
    (k.factorial * (n - k).factorial).divides(n.factorial)
    let c: Nat satisfy {
        (k.factorial * (n - k).factorial) * c = n.factorial
    }
}

let choose(n: Nat, k: Nat) -> c: Nat satisfy {
    if n < k {
        c = 0
    } else {
        c * k.factorial * (n - k).factorial = n.factorial
    }
}

attributes Nat {
    let choose = choose
}

theorem factorial_nonzero(n: Nat) {
    n.factorial != 0
} by {
    factorial_nonzero(0)
    forall(x: Nat) {
        if factorial_nonzero(x) {
            factorial_nonzero(x.suc)
        }
    }
}

theorem choose_zero(n: Nat) {
    n.choose(0) = 1
} by {
    not n < 0
    n.choose(0) * 0.factorial * (n - 0).factorial = n.factorial
    n.choose(0) * 1 * n.factorial = n.factorial
    n.choose(0) * n.factorial = n.factorial
    n.factorial != 0
}

theorem choose_n(n: Nat) {
    n.choose(n) = 1
} by {
    not n < n
    n.choose(n) * n.factorial * (n - n).factorial = n.factorial
    n.choose(n) * n.factorial * 1 = n.factorial
    n.choose(n) * n.factorial = n.factorial
    n.factorial != 0
}

theorem choose_add(a: Nat, b: Nat) {
    (a + b).choose(a) * a.factorial * b.factorial = (a + b).factorial
} by {
    not (a + b) < a
    (a + b).choose(a) * a.factorial * (a + b - a).factorial = (a + b).factorial
    (a + b - a).factorial = b.factorial
}

theorem choose_symm_add_form(a: Nat, b: Nat) {
    (a + b).choose(a) = (a + b).choose(b)
} by {
    a.factorial * b.factorial != 0
    (a + b).choose(a) * a.factorial * b.factorial = (a + b).factorial
    (a + b).choose(a) * (a.factorial * b.factorial) = (a + b).factorial
    (a + b).choose(b) * b.factorial * a.factorial = (a + b).factorial
    (a + b).choose(b) * (a.factorial * b.factorial) = (a + b).factorial
}

theorem choose_symm_sub_form(n: Nat, k: Nat) {
    k <= n implies n.choose(k) = n.choose(n - k)
} by {
    let a: Nat satisfy {
        k + a = n
    }
}

theorem choose_one(n: Nat) {
    n.choose(1) = n
} by {
    if n < 1 {
        n.choose(1) = 0
        n.choose(1) = n
    } else {
        n.choose(1) * 1.factorial * (n - 1).factorial = n.factorial
        n.choose(1) * 1 * (n - 1).factorial = n.factorial
        n.choose(1) * (n - 1).factorial = n.factorial
        n.factorial = n * (n - 1).factorial
        n.choose(1) * (n - 1).factorial = n * (n - 1).factorial
        (n - 1).factorial != 0
        n.choose(1) = n
    }
}

/// Pascal's identity: each entry in Pascal's triangle is the sum of the two entries above it.
theorem pascal(n: Nat, k: Nat) {
    0 < k and k <= n implies n.suc.choose(k) = n.choose(k - 1) + n.choose(k)
} by {
    // Establish key facts about k
    let (k_pred: Nat) satisfy { k_pred.suc = k }
    k_pred + 1 = k
    k - 1 = k_pred

    // Establish bounds
    k_pred < k
    k_pred <= n
    k_pred <= k
    k <= n.suc

    k.factorial * (n.suc - k).factorial != 0

    // LHS
    not n.suc < k
    n.suc.choose(k) * k.factorial * (n.suc - k).factorial = n.suc.factorial
    n.suc.choose(k) * (k.factorial * (n.suc - k).factorial) = n.suc.factorial

    // First term of RHS
    not n < k_pred
    n.choose(k_pred) * k_pred.factorial * (n - k_pred).factorial = n.factorial
    n - k_pred = n.suc - k
    n.choose(k_pred) * k_pred.factorial * (n.suc - k).factorial = n.factorial
    k.factorial = k * k_pred.factorial
    n.choose(k_pred) * k * k_pred.factorial * (n.suc - k).factorial = k * n.factorial
    n.choose(k_pred) * (k.factorial * (n.suc - k).factorial) = k * n.factorial
    n.choose(k - 1) * (k.factorial * (n.suc - k).factorial) = k * n.factorial

    // Second term of RHS
    not n < k
    n.choose(k) * k.factorial * (n - k).factorial = n.factorial
    n.suc - k = (n - k).suc
    (n.suc - k).factorial = (n - k).suc.factorial
    (n.suc - k).factorial = (n - k + 1) * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = n.choose(k) * k.factorial * (n - k + 1) * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = (n - k + 1) * n.choose(k) * k.factorial * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = (n - k + 1) * n.factorial
    n.choose(k) * (k.factorial * (n.suc - k).factorial) = (n - k + 1) * n.factorial

    // Sum
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = k * n.factorial + (n - k + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = (k + n - k + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = (n + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = n.suc * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = n.suc.factorial

    n.suc.choose(k) = n.choose(k - 1) + n.choose(k)
}