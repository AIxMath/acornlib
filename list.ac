from nat import Nat

inductive List<T> {
    nil
    cons(T, List<T>)
}

class List<T> {
    // Adding two lists concatenates them
    define add(self, other: List<T>) -> List<T> {
        match self {
            List.nil {
                other
            }
            List.cons(head, tail) {
                List.cons(head, tail.add(other))
            }
        }
    }

    // Whether this list contains a particular item.
    define contains(self, item: T) -> Bool {
        match self {
            List.nil {
                false
            }
            List.cons(head, tail) {
                if head = item {
                    true
                } else {
                    tail.contains(item)
                }
            }
        }
    }
}

theorem add_nil<T>(list: List<T>) {
    list + List.nil<T> = list
}

theorem nil_add<T>(list: List<T>) {
    List.nil<T> + list = list
}

theorem add_contains_left<T>(left: List<T>, right: List<T>, item: T) {
    left.contains(item) implies (left + right).contains(item)
} by {
    define f(x: List<T>) -> Bool {
        x.contains(item) implies (x + right).contains(item)
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

theorem add_contains_right<T>(left: List<T>, right: List<T>, item: T) {
    right.contains(item) implies (left + right).contains(item)
} by {
    define f(x: List<T>) -> Bool {
        (x + right).contains(item)
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

class List<T> {
    define contains_every(self) -> Bool {
        forall(x: T) {
            self.contains(x)
        }
    }

    define length(self) -> Nat {
        match self {
            List.nil {
                Nat.0
            }
            List.cons(_, tail) {
                tail.length.suc
            }
        }
    }
}

theorem add_length<T>(left: List<T>, right: List<T>) {
    left.length + right.length = (left + right).length
} by {
    define f(x: List<T>) -> Bool {
        x.length + right.length = (x + right).length
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

class List<T> {
    let singleton: T -> List<T> = function(x: T) {
        List.cons(x, List.nil<T>)
    }

    // Remove all the duplicates in the list.
    // The last one is kept, to make the implementation simpler.
    define unique(self) -> List<T> {
        match self {
            List.nil {
                List.nil<T>
            }
            List.cons(head, tail) {
                if tail.contains(head) {
                    tail.unique
                } else {
                    List.cons(head, tail.unique)
                }
            }
        }
    }
}

theorem unique_length<T>(list: List<T>) {
    list.unique.length <= list.length
} by {
    define f(x: List<T>) -> Bool {
        x.unique.length <= x.length
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            tail.unique.length <= tail.length
            if tail.contains(head) {
                List.cons(head, tail).unique.length <= List.cons(head, tail).length
            } else {
                List.cons(head, tail).unique.length <= List.cons(head, tail).length
            }
            f(List.cons(head, tail))
        }
    }
}

class List<T> {
    define append(self, item: T) -> List<T> {
        self + List.singleton(item)
    }
}

// A list of the numbers from 0 to n-1.
define range(n: Nat) -> List<Nat> {
    match n {
        Nat.0 {
            List.nil<Nat>
        }
        Nat.suc(n) {
            range(n).append(n)
        }
    }
}

