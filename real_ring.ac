from nat import Nat
from rat import Rat
from real_base import Real, min, max, is_cut, is_lower, is_greatest, has_greatest, is_dedekind_cut

// This file uses Cauchy sequences to define multiplication, and uses that to demonstrate that
// real numbers are a ring.

class Real {
    define is_close(self, other: Real, eps: Real) -> Bool {
        (self - other).abs < eps
    }
}

theorem close_imp_eps_pos(a: Real, b: Real, eps: Real) {
    a.is_close(b, eps) implies eps.is_positive
} by {
    (a - b).abs < eps
    (a - b).abs >= Real.0
    Real.0 <= (a - b).abs
    Real.0 < eps
    eps.is_positive
}

theorem close_comm(a: Real, b: Real, eps: Real) {
    a.is_close(b, eps) implies b.is_close(a, eps)
} by {
    a - b = -(b - a)
    (a - b).abs = (b - a).abs
    (a - b).abs < eps
    (b - a).abs < eps
}

theorem close_imp_bounds(a: Real, b: Real, eps: Real) {
    a.is_close(b, eps) implies b - eps < a and a < b + eps and a > b - eps and b < a + eps
} by {
    // Left ineq
    (a - b).abs < eps
    a - b <= (a - b).abs
    a - b < eps
    a - b + b < eps + b
    a < eps + b
    a < b + eps

    // Right ineq
    (b - a).abs < eps
    b - a <= (b - a).abs
    b - a < eps
    b - a + a < eps + a
    b - a + a = b
    b < eps + a
    eps + a > b
    a + eps > b
    a + eps + -eps > b + -eps
    a > b + -eps
}

theorem bounds_imp_close(a: Real, b: Real, eps: Real) {
    b - eps < a and a < b + eps implies a.is_close(b, eps)
} by {
    if (a - b).is_negative {
        (a - b).abs = b - a
        a > b + -eps
        a + eps + -eps > b + -eps
        a + eps > b
        eps + a > b
        b < eps + a
        b - a + a = b
        b - a + a < eps + a
        b - a < eps
        (a - b).abs < eps
        a.is_close(b, eps)
    } else {
        (a - b).abs = a - b
        a < eps + b
        a - b + b < eps + b
        a - b < eps
        a - b < eps
        (a - b).abs < eps
        a.is_close(b, eps)
    }
}

theorem sum_bounds_imp_close(a: Real, b: Real, eps: Real) {
    b < a + eps and a < b + eps implies a.is_close(b, eps)
} by {
    a + eps - eps <= a
    b + -eps < a
    b - eps < a
}

theorem self_close(a: Real, eps: Real) {
    eps.is_positive implies a.is_close(a, eps)
}

// Closeness is preserved in the real<->rat conversion.
theorem close_rats_imp_close_reals(q: Rat, r: Rat, eps: Rat) {
    q.is_close(r, eps) implies Real.from_rat(q).is_close(Real.from_rat(r), Real.from_rat(eps))
} by {
    (q - r).abs < eps
    Real.from_rat((q - r).abs) < Real.from_rat(eps)
    (Real.from_rat(q) - Real.from_rat(r)).abs < Real.from_rat(eps)
}

theorem close_reals_imp_close_rats(q: Rat, r: Rat, eps: Rat) {
    Real.from_rat(q).is_close(Real.from_rat(r), Real.from_rat(eps))
    implies q.is_close(r, eps)
} by {
    (Real.from_rat(q) - Real.from_rat(r)).abs < Real.from_rat(eps)
    Real.from_rat((q - r).abs) < Real.from_rat(eps)
    (q - r).abs < eps
}

// Every real can be approximated by a rational.
theorem rat_approx_exists(x: Real, eps: Rat) {
    eps.is_positive implies exists(r: Rat) {
        x.is_close(Real.from_rat(r), Real.from_rat(eps))
    }
} by {
    let r: Rat satisfy {
        Real.from_rat(r) < x and x < Real.from_rat(r + eps)
    }
    r - eps < r
    Real.from_rat(r - eps) < Real.from_rat(r)
    Real.from_rat(r) - Real.from_rat(eps) < Real.from_rat(r)
    Real.from_rat(r) - Real.from_rat(eps) < x
}

// Every real has a rational that is a distant upper bound.
theorem rat_upper(x: Real, eps: Rat) {
    eps.is_positive implies exists(r: Rat) {
        not x.is_close(Real.from_rat(r), Real.from_rat(eps)) and x < Real.from_rat(r)
    }
} by {
    let r1: Rat satisfy {
        x < Real.from_rat(r1)
    }
    let r: Rat = r1 + eps
    if x.is_close(Real.from_rat(r), Real.from_rat(eps)) {
        x < Real.from_rat(r) - Real.from_rat(eps)
        x < Real.from_rat(r - eps)
        x < Real.from_rat(r1)
        false
    }
    x < Real.from_rat(r)
}

// Every real has a rational that is a distant lower bound.
theorem rat_lower(x: Real, eps: Rat) {
    eps.is_positive implies exists(r: Rat) {
        not x.is_close(Real.from_rat(r), Real.from_rat(eps)) and Real.from_rat(r) < x
    }
} by {
    let r1: Rat satisfy {
        Real.from_rat(r1) < x
    }
    let r: Rat = r1 - eps
    if x.is_close(Real.from_rat(r), Real.from_rat(eps)) {
        Real.from_rat(r) + Real.from_rat(eps) < x
        Real.from_rat(r + eps) < x
        Real.from_rat(r1) < x
        false
    }
    r < r1
    Real.from_rat(r) < x
}

// Every intersecting pair of intervals has a rational number in it.
theorem rat_intersect(a: Real, b: Real, c: Real, d: Real, e: Real) {
    a.is_close(b, c) and a.is_close(d, e)
    implies
    exists(r: Rat) {
        Real.from_rat(r).is_close(b, c) and Real.from_rat(r).is_close(d, e)
    }
} by {
    a < b + c
    a < d + e
    a < min(b + c, d + e)
    let r: Rat satisfy {
        a < Real.from_rat(r) and Real.from_rat(r) < min(b + c, d + e)
    }
    Real.from_rat(r) < b + c
    b - c < a
    b - c < Real.from_rat(r)
    Real.from_rat(r).is_close(b, c)
    Real.from_rat(r) < d + e
    d - e < a
    d - e < Real.from_rat(r)
    Real.from_rat(r).is_close(d, e)
}

// The Cauchy condition for the convergence of a sequence.
define cauchy_condition(q: Nat -> Real, n: Nat, eps: Real) -> Bool {
    forall(i: Nat, j: Nat) {
        n <= i and n <= j implies q(i).is_close(q(j), eps)
    }
}

define converges(q: Nat -> Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(n: Nat) {
            cauchy_condition(q, n, eps)
        }
    }
}

// lb is eventually a lower bound of this sequence.
define eventual_lb(q: Nat -> Real, lb: Real) -> Bool {
    exists(n: Nat) {
        forall(i: Nat) {
            n <= i implies lb <= q(i)
        }
    }
}

// For demonstrating the equivalent of Cauchy sequences and Dedekind cuts.
define cauchy_gt_rat(q: Nat -> Real, r: Rat) -> Bool {
    exists(lb: Real) {
        lb > Real.from_rat(r) and eventual_lb(q, lb)
    }
}

theorem cauchy_gt_something(q: Nat -> Real) {
    converges(q) implies exists(r: Rat) {
        cauchy_gt_rat(q, r)
    }
} by {
    let eps: Real = Real.1
    eps.is_positive
    let n: Nat satisfy {
        cauchy_condition(q, n, eps)
    }
    let lb: Real satisfy {
        lb < q(n) - eps
    }
    let r: Rat satisfy {
        lb > Real.from_rat(r)
    }
    forall(i: Nat) {
        if n <= i {
            q(n).is_close(q(i), eps)
            q(i) > q(n) - eps
            q(i) > lb
            lb <= q(i)
        }
    }
    eventual_lb(q, lb)
    cauchy_gt_rat(q, r)
}

theorem cauchy_gt_not_everything(q: Nat -> Real) {
    converges(q) implies exists(r: Rat) {
        not cauchy_gt_rat(q, r)
    }
} by {
    let eps: Real = Real.1
    eps.is_positive
    let n: Nat satisfy {
        cauchy_condition(q, n, eps)
    }
    let r: Rat satisfy {
        Real.from_rat(r) > q(n) + eps
    }
    if cauchy_gt_rat(q, r) {
        let lb: Real satisfy {
            lb > Real.from_rat(r) and eventual_lb(q, lb)
        }
        let n2: Nat satisfy {
            forall(i: Nat) {
                n2 <= i implies q(i) >= lb
            }
        }
        if n <= n2 {
            q(n2).is_close(q(n), eps)
            not Real.from_rat(r) <= q(n) + Real.1
            not lb < q(n) + Real.1
            q(n2) > lb
            q(n2) > Real.from_rat(r)
            false
        } else {
            n2 <= n
            not Real.from_rat(r) <= q(n) + Real.1
            Real.from_rat(r) < lb + Real.1
            q(n) != lb
            q(n) > lb
            q(n) > Real.from_rat(r)
            false
        }
    }
}

theorem cauchy_gt_is_cut(q: Nat -> Real) {
    converges(q) implies is_cut(cauchy_gt_rat(q))
}

theorem cauchy_gt_is_lower(q: Nat -> Real) {
    converges(q) implies is_lower(cauchy_gt_rat(q))
} by {
    forall(x: Rat, y: Rat) {
        if cauchy_gt_rat(q, y) and x < y {
            let lb: Real satisfy {
                Real.from_rat(y) < lb and eventual_lb(q, lb)
            }
            Real.from_rat(x) < lb
            cauchy_gt_rat(q, x)
        }
    }
}

theorem cauchy_gt_has_no_greatest(q: Nat -> Real) {
    converges(q) implies not has_greatest(cauchy_gt_rat(q))
} by {
    if has_greatest(cauchy_gt_rat(q)) {
        let r: Rat satisfy {
            is_greatest(cauchy_gt_rat(q), r)
        }
        cauchy_gt_rat(q, r)
        let lb: Real satisfy {
            Real.from_rat(r) < lb and eventual_lb(q, lb)
        }
        let b: Rat satisfy {
            lb > Real.from_rat(b) and b > r
        }
        cauchy_gt_rat(q, b)
        false
    }
}

theorem cauchy_gt_is_dedekind_cut(q: Nat -> Real) {
    converges(q) implies is_dedekind_cut(cauchy_gt_rat(q))
}

define limit(q: Nat -> Real) -> Real {
    Real.new(cauchy_gt_rat(q))
}

theorem eventual_lb_extends(q: Nat -> Real, lb1: Real, lb2: Real) {
    eventual_lb(q, lb1) and lb2 < lb1 implies eventual_lb(q, lb2)
} by {
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies lb1 <= q(i)
        }
    }
    forall(i: Nat) {
        if n <= i {
            lb1 <= q(i)
            lb2 < lb1
            lb2 <= q(i)
        }
    }
}

theorem lt_limit_imp_lb(q: Nat -> Real, lb: Real) {
    converges(q) and lb < limit(q) implies eventual_lb(q, lb)
} by {
    let r: Rat satisfy {
        lb < Real.from_rat(r) and Real.from_rat(r) < limit(q)
    }
    limit(q).gt_rat(r)
    cauchy_gt_rat(q, r)
    let lb2: Real satisfy {
        lb2 > Real.from_rat(r) and eventual_lb(q, lb2)
    }
    lb < lb2
}

theorem lb_lte_limit(q: Nat -> Real, lb: Real) {
    converges(q) and eventual_lb(q, lb) implies lb <= limit(q)
}

// The other direction of the lower bound.
// We can prove basically the same stuff here.
define eventual_ub(q: Nat -> Real, ub: Real) -> Bool {
    exists(n: Nat) {
        forall(i: Nat) {
            n <= i implies q(i) <= ub
        }
    }
}

theorem eventual_ub_extends(q: Nat -> Real, ub1: Real, ub2: Real) {
    eventual_ub(q, ub1) and ub1 < ub2 implies eventual_ub(q, ub2)
} by {
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies q(i) <= ub1
        }
    }
    forall(i: Nat) {
        if n <= i {
            q(i) <= ub1
            q(i) <= ub2
        }
    }
}

define eventual_eq(q: Nat -> Real, a: Real) -> Bool {
    exists(n: Nat) {
        forall(i: Nat) {
            n <= i implies q(i) = a
        }
    }
}

theorem eventual_eq_imp_ub(q: Nat -> Real, a: Real) {
    eventual_eq(q, a) implies eventual_lb(q, a)
} by {
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies q(i) = a
        }
    }
    forall(i: Nat) {
        if n <= i {
            q(i) = a
        }
    }
}

theorem eventual_eq_imp_lb(q: Nat -> Real, a: Real) {
    eventual_eq(q, a) implies eventual_ub(q, a)
} by {
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies q(i) = a
        }
    }
    forall(i: Nat) {
        if n <= i {
            q(i) = a
        }
    }
}

theorem eq_converges(q: Nat -> Real, a: Real) {
    eventual_eq(q, a) implies converges(q)
} by {
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies q(i) = a
        }
    }
    forall(eps: Real) {
        if eps.is_positive {
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    q(i) = a
                    q(j) = a
                    q(i).is_close(q(j), eps)
                }
            }
            cauchy_condition(q, n, eps)
        }
    }
}

theorem lb_ub_imp_eq(q: Nat -> Real, a: Real) {
    eventual_lb(q, a) and eventual_ub(q, a) implies eventual_eq(q, a)
} by {
    let n1: Nat satisfy {
        forall(i: Nat) {
            n1 <= i implies q(i) <= a
        }
    }
    let n2: Nat satisfy {
        forall(i: Nat) {
            n2 <= i implies q(i) >= a
        }
    }
    let n: Nat satisfy {
        n1 <= n and n2 <= n
    }
    forall(i: Nat) {
        if n <= i {
            q(i) <= a
            q(i) >= a
            q(i) = a
        }
    }
}

theorem lb_lte_ub(q: Nat -> Real, lb: Real, ub: Real) {
    eventual_lb(q, lb) and eventual_ub(q, ub)
    implies
    lb <= ub
} by {
    let n1: Nat satisfy {
        forall(i: Nat) {
            n1 <= i implies lb <= q(i)
        }
    }
    let n2: Nat satisfy {
        forall(i: Nat) {
            n2 <= i implies q(i) <= ub
        }
    }
    let n: Nat satisfy {
        n1 <= n and n2 <= n
    }
    lb <= q(n)
    q(n) <= ub
}

theorem ub_imp_limit_lte(q: Nat -> Real, ub: Real) {
    converges(q) and eventual_ub(q, ub) implies limit(q) <= ub
} by {
    if limit(q) > ub {
        let r: Rat satisfy {
            limit(q) > Real.from_rat(r) and Real.from_rat(r) > ub
        }
        limit(q).gt_rat(r)
        let lb: Real satisfy {
            lb > Real.from_rat(r) and eventual_lb(q, lb)
        }
        lb > ub
        lb <= ub
        false
    }
}

// Relate the cauchy condition to eventual bounds

theorem cauchy_imp_lb(q: Nat -> Real, n: Nat, eps: Real) {
    cauchy_condition(q, n, eps) implies eventual_lb(q, q(n) - eps)
} by {
    forall(i: Nat) {
        if n <= i {
            q(i).is_close(q(n), eps)
            q(i) >= q(n) - eps
        }
    }
}

theorem cauch_imp_ub(q: Nat -> Real, n: Nat, eps: Real) {
    cauchy_condition(q, n, eps) implies eventual_ub(q, q(n) + eps)
} by {
    forall(i: Nat) {
        if n <= i {
            q(i).is_close(q(n), eps)
            q(i) <= q(n) + eps
        }
    }
}

theorem lt_imp_minus_pos(a: Real, b: Real) {
    a < b implies (b - a).is_positive
} by {
    forall(x0: Real) { a + x0 < b + x0 }
    (a + -b).is_negative
    (-(b + -a)).is_negative
    (-(b - a)).is_negative
}

theorem from_rat_pos(r: Rat) {
    r.is_positive implies Real.from_rat(r).is_positive
}

theorem sub_lte(a: Real, b: Real, c: Real) {
    a - c <= b implies a <= b + c
} by {
    a - c + c <= b + c
    a <= b + c
}

theorem limit_lt_imp_ub(q: Nat -> Real, ub: Real) {
    converges(q) and limit(q) < ub implies eventual_ub(q, ub)
} by {
    Real.0 < ub - limit(q)
    let eps2: Rat satisfy {
        eps2.is_positive and Real.from_rat(eps2) < (ub - limit(q))
    }
    let eps: Real = Real.from_rat(eps2 / Rat.2)
    (eps2 / Rat.2).is_positive
    eps.is_positive
    eps + eps = Real.from_rat(eps2)
    eps + eps < ub - limit(q)
    eps + eps + limit(q) < ub - limit(q) + limit(q)
    eps + eps + limit(q) < ub - limit(q) - -limit(q)
    eps + eps + limit(q) < ub
    limit(q) + eps + eps < ub

    let n: Nat satisfy {
        cauchy_condition(q, n, eps)
    }
    eventual_ub(q, q(n) + eps)
    eventual_lb(q, q(n) - eps)
    q(n) - eps <= limit(q)
    q(n) <= limit(q) + eps
    q(n) + eps <= limit(q) + eps + eps
    if q(n) + eps = limit(q) + eps + eps {
        eventual_ub(q, ub)
    } else {
        q(n) + eps < limit(q) + eps + eps
        q(n) + eps < ub
        eventual_ub(q, ub)
    }
}

theorem eq_imp_limit(q: Nat -> Real, a: Real) {
    eventual_eq(q, a) implies limit(q) = a
} by {
    converges(q)
    eventual_ub(q, a)
    eventual_lb(q, a)
    if limit(q) < a {
        let ub: Real satisfy {
            limit(q) < ub and ub < a
        }
        eventual_ub(q, ub)
        a < ub
        false
    }
    if limit(q) > a {
        let lb: Real satisfy {
            a < lb and lb < limit(q)
        }
        eventual_lb(q, lb)
        a > lb
        false
    }
}

// converges_to is the Weierstrass definition.
define converges_to(q: Nat -> Real, a: Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(n: Nat) {
            forall(i: Nat) {
                n <= i implies q(i).is_close(a, eps)
            }
        }
    }
}

theorem lt_converges_to_imp_lb(q: Nat -> Real, a: Real, b: Real) {
    converges_to(q, b) and a < b implies eventual_lb(q, a)
} by {
    let eps: Real = b - a
    eps.is_positive
    eps + a = b
    a = b - eps
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies q(i).is_close(b, eps)
        }
    }
    forall(i: Nat) {
        if n <= i {
            q(i).is_close(b, eps)
            q(i) >= b - eps
            q(i) >= a
        }
    }
}

theorem gt_converges_to_imp_ub(q: Nat -> Real, a: Real, b: Real) {
    converges_to(q, b) and a > b implies eventual_ub(q, a)
} by {
    let eps: Real = a - b
    eps.is_positive
    a = b + eps
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies q(i).is_close(b, eps)
        }
    }
    forall(i: Nat) {
        if n <= i {
            q(i).is_close(b, eps)
            q(i) <= b + eps
            q(i) <= a
        }
    }
}

theorem eps_lt_half(a: Real) {
    a.is_positive implies exists(b: Real) {
        b.is_positive and b + b < a
    }
} by {
    Real.0 < a
    let c: Rat satisfy {
        Real.0 < Real.from_rat(c) and Real.from_rat(c) < a
    }
    let b: Rat = c / Rat.2
    b + b = c
    (Real.from_rat(c) - Real.0).is_positive
    Real.from_rat(c).gt_rat(Rat.0)
    Rat.0 < c
    c.is_positive
    b.is_positive
    Real.from_rat(b).is_positive
    Real.from_rat(b) + Real.from_rat(b) = Real.from_rat(c)
}

theorem add_gt_imp_gt_sub(a: Real, b: Real, c: Real) {
    a + b > c implies a > c - b
} by {
    a + b > c
    a + b + -b > c + -b
    a > c - b
}

theorem sub_either_order(a: Real, b: Real, c: Real) {
    a - b - c = a - c - b
}

theorem sub_both_eq_sub_add(a: Real, b: Real, c: Real) {
    a - b - c = a - (b + c)
}

theorem is_close_triangle(a: Real, b: Real, c: Real, ace: Real, bce: Real) {
    a.is_close(c, ace) and b.is_close(c, bce)
    implies
    a.is_close(b, ace + bce)
} by {
    // First let's lower-bound a
    a > c - ace
    a + ace > c
    c > b - bce
    a + ace > b - bce
    a > b - bce - ace
    a > b - ace - bce
    a > b - (ace + bce)

    // Then let's upper-bound a
    a < c + ace
    c < b + bce
    c + ace < b + bce + ace
    a < b + ace + bce

    a.is_close(b, ace + bce)
}

// Prove our two definitions of convergence are equivalent.

theorem converges_to_imp_converges(q: Nat -> Real, a: Real) {
    converges_to(q, a) implies converges(q)
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and eps2 + eps2 < eps
            }
            let n: Nat satisfy {
                forall(i: Nat) {
                    n <= i implies q(i).is_close(a, eps2)
                }
            }
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    q(i).is_close(a, eps2)
                    q(j).is_close(a, eps2)
                    q(i).is_close(q(j), eps2 + eps2)
                    q(i).is_close(q(j), eps)
                }
            }
            cauchy_condition(q, n, eps)
        }
    }
}

theorem sub_lt_is_gt(a: Real, b: Real, c: Real) {
    b < c implies a - b > a - c
} by {
    -c < -b
    a + -c < a + -b
    a + -b > a - c
}

theorem converges_imp_converges_to(q: Nat -> Real) {
    converges(q) implies converges_to(q, limit(q))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and eps2 < eps
            }

            // Find a lower bound
            let lb: Real = limit(q) - eps2
            lb < limit(q)
            limit(q) - eps2 > limit(q) - eps
            lb > limit(q) - eps
            eventual_lb(q, lb)
            let n1: Nat satisfy {
                forall(i: Nat) {
                    n1 <= i implies q(i) >= lb
                }
            }

            // Find an upper bound
            let ub: Real = limit(q) + eps2
            ub > limit(q)
            limit(q) + eps2 < limit(q) + eps
            ub < limit(q) + eps
            eventual_ub(q, ub)
            let n2: Nat satisfy {
                forall(i: Nat) {
                    n2 <= i implies q(i) <= ub
                }
            }

            // Once both of those are hit, the Weierstrass condition is ok
            let n: Nat satisfy {
                n1 <= n and n2 <= n
            }
            forall(i: Nat) {
                if n <= i {
                    q(i) >= lb
                    q(i) > limit(q) - eps
                    q(i) <= ub
                    q(i) < limit(q) + eps
                    q(i).is_close(limit(q), eps)
                }
            }
        }
    }
}

theorem converges_to_unique_one_way(q: Nat -> Real, a: Real, b: Real) {
    converges_to(q, a) and converges_to(q, b) implies not a < b
} by {
    converges(q)
    if a < b {
        let r1: Real satisfy {
            a < r1 and r1 < b
        }
        let r2: Real satisfy {
            r1 < r2 and r2 < b
        }
        eventual_ub(q, r1)
        limit(q) <= r1
        eventual_lb(q, r2)
        limit(q) >= r2
        r2 <= r1
        false
    }
}

theorem converges_to_unique(q: Nat -> Real, a: Real, b: Real) {
    converges_to(q, a) and converges_to(q, b) implies a = b
} by {
    if a < b {
        false
    }
    if b < a {
        false
    }
}

// The condition for uniform continuity on the rationals.
define rat_condition(f: Rat -> Real, delta: Rat, eps: Real) -> Bool {
    forall(r1: Rat, r2: Rat) {
        r1.is_close(r2, delta) implies f(r1).is_close(f(r2), eps)
    }
}

// The definition of uniform continuity on the rationals.
define rat_uniform(f: Rat -> Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(delta: Rat) {
            delta.is_positive and rat_condition(f, delta, eps)
        }
    }
}

// Probably this should go somewhere else.
define compose<T, U, V>(f: U -> V, g: T -> U) -> T -> V {
    function(t: T) {
        f(g(t))
    }
}

// Lifting a sequence of rationals to a sequence of reals
define lift_seq(q: Nat -> Rat) -> Nat -> Real {
    compose(Real.from_rat, q)
}

theorem lift_seq_elt(q: Nat -> Rat, n: Nat) {
    lift_seq(q)(n) = Real.from_rat(q(n))
} by {
    lift_seq(q)(n) = compose(Real.from_rat, q)(n)
    lift_seq(q)(n) = Real.from_rat(q(n))
}

// Uniform continuity implies sequential continuity.
theorem uniform_imp_seq(f: Rat -> Real, q: Nat -> Rat) {
    rat_uniform(f) and converges(lift_seq(q))
    implies
    converges(compose(f, q))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let delta: Rat satisfy {
                delta.is_positive and rat_condition(f, delta, eps)
            }
            let n: Nat satisfy {
                cauchy_condition(lift_seq(q), n, Real.from_rat(delta))
            }

            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    lift_seq(q)(i).is_close(lift_seq(q)(j), Real.from_rat(delta))
                    Real.from_rat(q(i)).is_close(Real.from_rat(q(j)), Real.from_rat(delta))
                    q(i).is_close(q(j), delta)
                    f(q(i)).is_close(f(q(j)), eps)
                    compose(f, q)(i).is_close(compose(f, q)(j), eps)
                }
            }

            cauchy_condition(compose(f, q), n, eps)
        }
    }
}

let rat_approx(x: Real, eps: Rat) -> r: Rat satisfy {
    eps.is_positive implies
    x.is_close(Real.from_rat(r), Real.from_rat(eps))
}

// A sequence of rationals that approximates a real number.
// Chosen to be easy to calculate with.
define rat_seq(x: Real, n: Nat) -> Rat {
    rat_approx(x, rat.iop(n))
}

theorem rat_seq_is_close(x: Real, n: Nat) {
    x.is_close(Real.from_rat(rat_seq(x, n)), Real.from_rat(rat.iop(n)))
}

theorem abs_lt_imp_close_to_zero(x: Real, eps: Real) {
    x.abs < eps implies x.is_close(Real.0, eps)
} by {
    if x.is_negative {
        x.abs = -x
        -x < eps
        x > -eps
        x.is_close(Real.0, eps)
    } else {
        x.abs = x
        x < eps
        x.is_close(Real.0, eps)
    }
}

theorem iop_limit {
    converges_to(lift_seq(rat.iop), Real.0)
} by {
    forall(eps: Real) {
        if eps.is_positive {
            Real.0 < eps
            let reps: Rat satisfy {
                reps.is_positive and Real.from_rat(reps) < eps
            }
            let n: Nat satisfy {
                forall(i: Nat) {
                    n <= i implies rat.iop(i) < reps
                }
            }

            forall(i: Nat) {
                if n <= i {
                    rat.iop(i) < reps
                    rat.iop(i).is_positive
                    Real.from_rat(rat.iop(i)).is_positive
                    Real.from_rat(rat.iop(i)).abs = Real.from_rat(rat.iop(i))
                    Real.from_rat(rat.iop(i)) < eps
                    Real.from_rat(rat.iop(i)).abs < eps
                    lift_seq(rat.iop)(i) = Real.from_rat(rat.iop(i))
                    lift_seq(rat.iop)(i).abs < eps
                    lift_seq(rat.iop)(i).is_close(Real.0, eps)
                }
            }
        }
    }
}

define add_seq(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    a(n) + b(n)
}

theorem half_pos_is_pos(a: Real, b: Real) {
    b.is_positive and a + a = b
    implies
    a.is_positive
}

theorem add_close(a1: Real, b1: Real, a2: Real, b2: Real, a_eps: Real, b_eps: Real) {
    a1.is_close(a2, a_eps) and b1.is_close(b2, b_eps)
    implies
    (a1 + b1).is_close(a2 + b2, a_eps + b_eps)
} by {
    // The less-than direction
    a1 < a2 + a_eps
    b2 < b2 + b_eps
    a1 + b1 < a2 + a_eps + b2 + b_eps
    a1 + b1 < (a2 + b2) + (a_eps + b_eps)

    // The greater-than direction
    a1 > a2 - a_eps
    b2 > b2 - b_eps
    a1 + b1 > (a2 - a_eps) + (b2 - b_eps)
    a2 - a_eps + (b2 - b_eps) != a1 + b1
    max(a1 + b1, a2 - a_eps + (b2 - b_eps)) = a1 + b1
    max(a1 + b1, a2 + b2 - (a_eps + b_eps)) != a2 + b2 - (a_eps + b_eps)
    a1 + b1 > (a2 + b2) - (a_eps + b_eps)
}

theorem limit_add_seq(a: Nat -> Real, b: Nat -> Real) {
    converges(a) and converges(b)
    implies
    converges_to(add_seq(a, b), limit(a) + limit(b))
} by {
    let q: Nat -> Real = add_seq(a, b)
    let ql: Real = limit(a) + limit(b)
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and eps2 + eps2 < eps
            }

            let n1: Nat satisfy {
                forall(i: Nat) {
                    n1 <= i implies a(i).is_close(limit(a), eps2)
                }
            }

            let n2: Nat satisfy {
                forall(i: Nat) {
                    n2 <= i implies b(i).is_close(limit(b), eps2)
                }
            }

            let n: Nat satisfy {
                n1 <= n and n2 <= n
            }

            forall(i: Nat) {
                if n <= i {
                    a(i).is_close(limit(a), eps2)
                    b(i).is_close(limit(b), eps2)
                    (a(i) + b(i)).is_close(limit(a) + limit(b), eps2 + eps2)
                    (q(i) - ql).abs < eps
                    q(i).is_close(ql, eps)
                }
            }
        }
    }
    converges_to(q, ql)
}

theorem lift_rat_seq_close(x: Real, n: Nat) {
    lift_seq(rat_seq(x))(n).is_close(x, Real.from_rat(rat.iop(n)))
}

theorem rat_seq_converges_to(x: Real) {
    converges_to(lift_seq(rat_seq(x)), x)
} by {
    forall(eps: Real) {
        if eps.is_positive {
            Real.0 < eps
            let reps: Rat satisfy {
                Real.from_rat(reps) < eps and reps.is_positive
            }
            let n: Nat satisfy {
                forall(i: Nat) {
                    n <= i implies rat.iop(i) < reps
                }
            }

            forall(i: Nat) {
                if n <= i {
                    lift_seq(rat_seq(x))(i).is_close(x, Real.from_rat(rat.iop(i)))
                    Real.from_rat(rat.iop(i)) < eps
                    (Real.from_rat(rat_seq(x, i)) - x).abs < eps
                    lift_seq(rat_seq(x))(i).is_close(x, eps)
                }
            }
        }
    }
}

// The condition for uniform continuity on the reals.
define uniform_condition(f: Real -> Real, delta: Real, eps: Real) -> Bool {
    forall(r1: Real, r2: Real) {
        r1.is_close(r2, delta) implies f(r1).is_close(f(r2), eps)
    }
}

// The definition of uniform continuity on the reals.
define uniform(f: Real -> Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(delta: Real) {
            delta.is_positive and uniform_condition(f, delta, eps)
        }
    }
}

theorem limit_compose_uniform(f: Real -> Real, a: Nat -> Real) {
    uniform(f) and converges(a)
    implies
    converges_to(compose(f, a), f(limit(a)))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let delta: Real satisfy {
                delta.is_positive and uniform_condition(f, delta, eps)
            }
            let n: Nat satisfy {
                forall(i: Nat) {
                    n <= i implies a(i).is_close(limit(a), delta)
                }
            }

            forall(i: Nat) {
                if n <= i {
                    compose(f, a)(i).is_close(f(limit(a)), eps)
                }
            }
        }
    }
}

theorem limit_compose_rat_uniform(f: Rat -> Real, a: Nat -> Rat, r: Rat) {
    rat_uniform(f)
    and converges_to(lift_seq(a), Real.from_rat(r))
    implies
    converges_to(compose(f, a), f(r))
} by {
    let fa: Nat -> Real = compose(f, a)
    forall(eps: Real) {
        if eps.is_positive {
            let delta: Rat satisfy {
                delta.is_positive and rat_condition(f, delta, eps)
            }
            Real.from_rat(delta).is_positive
            let n: Nat satisfy {
                forall(i: Nat) {
                    n <= i implies lift_seq(a)(i).is_close(Real.from_rat(r), Real.from_rat(delta))
                }
            }

            forall(i: Nat) {
                if n <= i {
                    lift_seq(a)(i).is_close(Real.from_rat(r), Real.from_rat(delta))
                    a(i).is_close(r, delta)
                    f(a(i)).is_close(f(r), eps)
                    compose(f, a)(i).is_close(f(r), eps)
                    fa(i).is_close(f(r), eps)
                }
            }
        }
    }
    converges_to(fa, f(r))
}

// Lifting a uniformly continuous function of rationals
// to a function over the reals.
define lift_uc(f: Rat -> Real, x: Real) -> Real {
    limit(compose(f, rat_seq(x)))
}

theorem lift_fixes_rats(f: Rat -> Real, r: Rat) {
    rat_uniform(f)
    implies
    lift_uc(f, Real.from_rat(r)) = f(r)
} by {
    converges_to(lift_seq(rat_seq(Real.from_rat(r))), Real.from_rat(r))
    converges_to(compose(f, rat_seq(Real.from_rat(r))), f(r))
    limit(compose(f, rat_seq(Real.from_rat(r)))) = f(r)
}

theorem rat_close_to_both_lt(x: Real, y: Real, eps: Real) {
    x.is_close(y, eps) and x < y implies
    exists(r: Rat) {
        x.is_close(Real.from_rat(r), eps)
        and
        y.is_close(Real.from_rat(r), eps)
    }
} by {
    let r: Rat satisfy {
        x < Real.from_rat(r) and Real.from_rat(r) < y
    }
    Real.from_rat(r) < x + eps
    y < Real.from_rat(r) + eps
    x.is_close(Real.from_rat(r), eps)
}

theorem rat_close(x: Real, y: Real, eps: Real) {
    x.is_close(y, eps) implies
    exists(r: Rat) {
        x.is_close(Real.from_rat(r), eps)
        and
        y.is_close(Real.from_rat(r), eps)
    }
} by {
    y.is_close(x, eps)
    if x < y {
        exists(r: Rat) {
            x.is_close(Real.from_rat(r), eps)
            and
            y.is_close(Real.from_rat(r), eps)
        }
    } else {
        if y < x {
            exists(r: Rat) {
                x.is_close(Real.from_rat(r), eps)
                and
                y.is_close(Real.from_rat(r), eps)
            }
        } else {
            x = y
            let r1: Rat satisfy {
                x.is_close(Real.from_rat(r1), eps)
            }
            exists(r2: Rat) {
                x.is_close(Real.from_rat(r2), eps)
                and
                y.is_close(Real.from_rat(r2), eps)
            }
        }
    }
}

theorem lift_rat_seq_converges(x: Real) {
    converges(lift_seq(rat_seq(x)))
}

// When two sequences get close to each other eventually.
define seq_close(a: Nat -> Real, b: Nat -> Real, eps: Real) -> Bool {
    exists(n: Nat) {
        forall(i: Nat) {
            n <= i implies a(i).is_close(b(i), eps)
        }
    }
}

theorem convergent_seqs_get_close(a: Nat -> Real, b: Nat -> Real, eps: Real) {
    eps.is_positive and converges(a) and converges(b) and limit(a) = limit(b)
    implies
    seq_close(a, b, eps)
} by {
    let eps2: Real satisfy {
        eps2.is_positive and eps2 + eps2 < eps
    }
    let n1: Nat satisfy {
        forall(i: Nat) {
            n1 <= i implies a(i).is_close(limit(a), eps2)
        }
    }
    let n2: Nat satisfy {
        forall(i: Nat) {
            n2 <= i implies b(i).is_close(limit(b), eps2)
        }
    }
    let n: Nat satisfy {
        n1 <= n and n2 <= n
    }
    forall(i: Nat) {
        if n <= i {
            a(i).is_close(limit(a), eps2)
            b(i).is_close(limit(b), eps2)
            a(i).is_close(b(i), eps2 + eps2)
            (a(i) - b(i)).abs < eps
            a(i).is_close(b(i), eps)
        }
    }
}

theorem only_abs_zero_eq_zero(x: Real) {
    x.abs = Real.0 implies x = Real.0
}

theorem close_limit_imp_seqs_get_close(a: Nat -> Real, b: Nat -> Real, eps: Real) {
    converges(a) and converges(b) and limit(a).is_close(limit(b), eps)
    implies
    seq_close(a, b, eps)
} by {
    if limit(a) = limit(b) {
        seq_close(a, b, eps)
    } else {
        limit(a) != limit(b)
        let diff: Real = (limit(a) - limit(b)).abs
        (limit(a) - limit(b)) != Real.0
        diff != Real.0
        diff.is_positive
        diff < eps
        let eps2: Real satisfy {
            diff < eps2 and eps2 < eps
        }
        limit(a).is_close(limit(b), eps2)
        let eps3: Real satisfy {
            eps3.is_positive and eps2 + eps3 < eps
        }
        let eps4: Real satisfy {
            eps4.is_positive and eps4 + eps4 < eps3
        }
        let n1: Nat satisfy {
            forall(i: Nat) {
                n1 <= i implies a(i).is_close(limit(a), eps4)
            }
        }
        let n2: Nat satisfy {
            forall(i: Nat) {
                n2 <= i implies b(i).is_close(limit(b), eps4)
            }
        }
        let n: Nat satisfy {
            n1 <= n and n2 <= n
        }
        forall(i: Nat) {
            if n <= i {
                n1 <= i
                n2 <= i
                a(i).is_close(limit(a), eps4)
                b(i).is_close(limit(b), eps4)
                a(i).is_close(limit(b), eps4 + eps2)
                a(i).is_close(b(i), eps4 + eps2 + eps4)
                a(i).is_close(b(i), eps4 + eps4 + eps2)
                eps3 + eps2 < eps
                eps4 + eps4 + eps2 < eps3 + eps2
                eps4 + eps4 + eps2 < eps
                (a(i) - b(i)).abs < eps
                a(i).is_close(b(i), eps)
            }
        }
        seq_close(a, b, eps)
    }
}

theorem close_and_lt_imp_close(x: Real, y: Real, eps1: Real, eps2: Real) {
    x.is_close(y, eps1) and eps1 < eps2 implies x.is_close(y, eps2)
}

theorem find_less_than_a_third(x: Real) {
    x.is_positive implies
    exists(eps: Real) {
        eps.is_positive and eps + eps + eps < x
    }
} by {
    Real.0 < x
    let r: Rat satisfy {
        r.is_positive and Real.from_rat(r) < x
    }
    let reps: Rat = r / Rat.3
    reps + reps + reps = r
    Real.from_rat(reps) + Real.from_rat(reps) + Real.from_rat(reps) = Real.from_rat(r)
    Real.from_rat(reps) + Real.from_rat(reps) + Real.from_rat(reps) < x
}

define limit_rat(a: Nat -> Rat) -> Real {
    limit(lift_seq(a))
}

theorem lift_uniform_is_uniform(f: Rat -> Real) {
    rat_uniform(f)
    implies
    uniform(lift_uc(f))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            // We split epsilon into three because we have three approximations to combine:
            // f(a) is close to f(a_i) is close to f(b_i) is close to f(b).
            let eps3: Real satisfy {
                eps3.is_positive and eps3 + eps3 + eps3 < eps
            }

            let delta: Rat satisfy {
                delta.is_positive and rat_condition(f, delta, eps3)
            }

            forall(a: Real, b: Real) {
                if a.is_close(b, Real.from_rat(delta)) {
                    // f(a_i) is approximately f(a)
                    let fas: Nat -> Real = compose(f, rat_seq(a))
                    converges(fas)
                    converges_to(fas, limit(fas))
                    let n1: Nat satisfy {
                        forall(i: Nat) {
                            n1 <= i implies
                            fas(i).is_close(limit(fas), eps3)
                        }
                    }

                    // f(b_i) is approximately f(b)
                    let fbs: Nat -> Real = compose(f, rat_seq(b))
                    converges(fbs)
                    converges_to(fbs, limit(fbs))
                    let n2: Nat satisfy {
                        forall(i: Nat) {
                            n2 <= i implies
                            fbs(i).is_close(limit(fbs), eps3)
                        }
                    }

                    // f(a_i) and f(b_i) are close
                    limit(lift_seq(rat_seq(a))) = a
                    limit_rat(rat_seq(a)) = a
                    limit(lift_seq(rat_seq(b))) = b
                    limit_rat(rat_seq(b)) = b
                    limit_rat(rat_seq(a)).is_close(limit_rat(rat_seq(b)), Real.from_rat(delta))
                    converges(lift_seq(rat_seq(a)))
                    converges(lift_seq(rat_seq(b)))
                    seq_close(lift_seq(rat_seq(a)), lift_seq(rat_seq(b)), Real.from_rat(delta))
                    let n3: Nat satisfy {
                        forall(i: Nat) {
                            n3 <= i implies
                            lift_seq(rat_seq(a))(i).is_close(lift_seq(rat_seq(b))(i), Real.from_rat(delta))
                        }
                    }

                    let n: Nat satisfy {
                        n1 <= n and n2 <= n and n3 <= n
                    }
                    fas(n).is_close(limit(fas), eps3)
                    fbs(n).is_close(limit(fbs), eps3)
                    lift_seq(rat_seq(a))(n).is_close(lift_seq(rat_seq(b))(n), Real.from_rat(delta))
                    rat_seq(a)(n).is_close(rat_seq(b)(n), delta)
                    f(rat_seq(a)(n)).is_close(f(rat_seq(b)(n)), eps3)
                    limit(fas).is_close(fas(n), eps3)
                    fas(n).is_close(fbs(n), eps3)
                    limit(fas).is_close(fbs(n), eps3 + eps3)
                    limit(fas).is_close(limit(fbs), eps3 + eps3 + eps3)
                    limit(fas).is_close(limit(fbs), eps)

                    lift_uc(f)(a).is_close(lift_uc(f)(b), eps)
                }
            }

            uniform_condition(lift_uc(f), Real.from_rat(delta), eps)
            delta.is_positive and uniform_condition(lift_uc(f), Real.from_rat(delta), eps)
        }
    }
}

theorem neq_imp_abs_diff_pos(x: Real, y: Real) {
    x != y implies (x - y).abs.is_positive
} by {
    if x < y {
        x - y < Real.0
        (x - y) != Real.0
        (x - y).abs.is_positive
    } else {
        x >= y
        x > y
        x - y > Real.0
        (x - y).abs.is_positive
    }
}

theorem eps_smaller_than_both(eps1: Real, eps2: Real) {
    eps1.is_positive and eps2.is_positive implies
    exists(eps3: Real) {
        eps3.is_positive and eps3 < eps1 and eps3 < eps2
    }
} by {
    Real.0 < min(eps1, eps2)
    let eps3: Real satisfy {
        Real.0 < eps3 and eps3 < min(eps1, eps2)
    }
    eps3.is_positive and eps3 < eps1 and eps3 < eps2
}

// When two uniform functions are not equal, they differ on some rational number.
theorem uniform_ne_imp_rat_ne(f: Real -> Real, g: Real -> Real) {
    uniform(f) and uniform(g) and f != g implies
    exists(r: Rat) {
        f(Real.from_rat(r)) != g(Real.from_rat(r))
    }
} by {
    let x: Real satisfy {
        f(x) != g(x)
    }
    let eps: Real = (f(x) - g(x)).abs
    eps.is_positive
    not f(x).is_close(g(x), eps)
    let eps2: Real satisfy {
        eps2.is_positive and eps2 + eps2 < eps
    }

    let delta1: Real satisfy {
        delta1.is_positive and uniform_condition(f, delta1, eps2)
    }
    let delta2: Real satisfy {
        delta2.is_positive and uniform_condition(g, delta2, eps2)
    }
    let delta: Real satisfy {
        delta.is_positive and delta < delta1 and delta < delta2
    }

    let r: Rat satisfy {
        Real.from_rat(r).is_close(x, delta)
    }
    Real.from_rat(r).is_close(x, delta1)
    f(Real.from_rat(r)).is_close(f(x), eps2)
    Real.from_rat(r).is_close(x, delta2)
    g(Real.from_rat(r)).is_close(g(x), eps2)
    if f(Real.from_rat(r)) = g(Real.from_rat(r)) {
        f(x).is_close(f(Real.from_rat(r)), eps2)
        f(Real.from_rat(r)).is_close(g(x), eps2)
        f(x).is_close(g(x), eps2 + eps2)
        f(x).is_close(g(x), eps)
        false
    }
}

define rat_increasing(f: Rat -> Real) -> Bool {
    forall(r1: Rat, r2: Rat) {
        r1 < r2 implies f(r1) < f(r2)
    }
}

define increasing(f: Real -> Real) -> Bool {
    forall(x: Real, y: Real) {
        x < y implies f(x) < f(y)
    }
}

theorem uni_cond_imp_rat_cond(f: Real -> Real, delta: Rat, eps: Real) {
    uniform_condition(f, Real.from_rat(delta), eps)
    implies
    rat_condition(compose(f, Real.from_rat), delta, eps)
}

theorem uniform_imp_rat_uniform(f: Real -> Real) {
    uniform(f)
    implies
    rat_uniform(compose(f, Real.from_rat))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let delta: Real satisfy {
                delta.is_positive and uniform_condition(f, delta, eps)
            }
            Real.0 < delta
            let rdelta: Rat satisfy {
                rdelta.is_positive and Real.from_rat(rdelta) < delta
            }
            uniform_condition(f, Real.from_rat(rdelta), eps)
            rdelta.is_positive and rat_condition(compose(f, Real.from_rat), rdelta, eps)
        }
    }
}

theorem tighten_uc(f: Real -> Real, delta1: Real, delta2: Real, eps: Real) {
    delta1.is_positive and delta2.is_positive and
    uniform_condition(f, delta1, eps) and delta2 < delta1
    implies
    uniform_condition(f, delta2, eps)
}

theorem lift_inc_is_inc(f: Rat -> Real) {
    rat_uniform(f) and rat_increasing(f)
    implies
    increasing(lift_uc(f))
} by {
    let lf: Real -> Real = lift_uc(f)
    uniform(lf)
    forall(r: Rat) {
        lf(Real.from_rat(r)) = f(r)
    }
    forall(x: Real, y: Real) {
        if x < y {
            let r1: Rat satisfy {
                x < Real.from_rat(r1) and Real.from_rat(r1) < y
            }
            let r2: Rat satisfy {
                r1 < r2 and Real.from_rat(r2) < y
            }
            f(r1) < f(r2)
            let eps: Real satisfy {
                eps.is_positive and f(r1) + eps < f(r2)
            }
            let eps2: Real satisfy {
                eps2.is_positive and eps2 + eps2 < eps
            }

            // Pick delta1 so that f(xr) is close to f(x)
            let delta1: Real satisfy {
                delta1.is_positive and
                uniform_condition(lf, delta1, eps2)
            }

            // Pick delta2 so that xr is close to x and yr is close to y
            let delta2a: Real satisfy {
                delta2a.is_positive and
                x + delta2a < Real.from_rat(r1)
            }
            let delta2b: Real satisfy {
                delta2b.is_positive and
                Real.from_rat(r2) + delta2b < y
            }
            let delta2: Real satisfy {
                delta2.is_positive and
                delta2 < delta2a and
                delta2 < delta2b
            }

            // Delta satisfies all these conditions
            let delta: Real satisfy {
                delta.is_positive and
                delta < delta1 and
                delta < delta2
            }
            delta < delta2a
            delta < delta2b

            let xr: Rat satisfy {
                Real.from_rat(xr).is_close(x, delta)
            }
            Real.from_rat(xr) < x + delta
            x + delta <= x + delta2a
            Real.from_rat(xr) < x + delta2a
            Real.from_rat(xr) < Real.from_rat(r1)
            xr < r1

            let yr: Rat satisfy {
                Real.from_rat(yr).is_close(y, delta)
            }
            Real.from_rat(r2) + delta < Real.from_rat(r2) + delta2b
            Real.from_rat(r2) + delta < y
            y < Real.from_rat(yr) + delta
            Real.from_rat(r2) + delta < Real.from_rat(yr) + delta
            Real.from_rat(r2) < Real.from_rat(yr)
            r2 < yr

            forall(z: Real, zr: Rat) {
                if Real.from_rat(zr).is_close(z, delta1) {
                    lf(Real.from_rat(zr)).is_close(lf(z), eps2)
                    f(zr).is_close(lf(z), eps2)
                }
            }
            Real.from_rat(xr).is_close(x, delta1)
            f(xr).is_close(lf(x), eps2)
            Real.from_rat(yr).is_close(y, delta1)
            f(yr).is_close(lf(y), eps2)

            f(xr) < f(r1)
            f(r2) < f(yr)
            f(r1) + eps <= f(r2)
            f(xr) + eps < f(r1) + eps
            f(r2) <= f(yr)
            f(r1) + eps < f(yr)
            f(xr) + eps < f(yr)

            lf(x) < f(xr) + eps2
            f(xr) + (eps2 + eps2) < f(xr) + eps
            f(xr) + eps2 + eps2 < f(xr) + eps
            f(xr) + eps2 + eps2 < f(yr)
            lf(x) + eps2 < f(xr) + eps2 + eps2
            lf(x) + eps2 < f(yr)
            f(yr) < lf(y) + eps2
            lf(x) + eps2 < lf(y) + eps2
            lf(x) < lf(y)

            lift_uc(f)(x) < lift_uc(f)(y)
        }
    }
}

define is_constant<T, U>(f: T -> U) -> Bool {
    exists(y: U) {
        forall(x: T) {
            f(x) = y
        }
    }
}

theorem constant_is_rat_uniform(f: Rat -> Real) {
    is_constant(f)
    implies
    rat_uniform(f)
}

theorem constant_is_uniform(f: Real -> Real) {
    is_constant(f)
    implies
    uniform(f)
} by {
    forall(eps: Real) {
        if eps.is_positive {
            forall(x: Real, y: Real) {
                f(x).is_close(f(y), eps)
            }
            uniform_condition(f, eps, eps)
        }
    }
}

theorem lift_constant_is_constant(f: Rat -> Real) {
    is_constant(f)
    implies
    is_constant(lift_uc(f))
} by {
    rat_uniform(f)
    let (y: Real) satisfy {
        forall(r: Rat) {
            f(r) = y
        }
    }
    forall(x: Real) {
        forall(n: Nat) {
            compose(f, rat_seq(x))(n) = y
        }
        limit(compose(f, rat_seq(x))) = y
        lift_uc(f)(x) = y
    }
}

theorem compose_uniform(f: Real -> Real, g: Real -> Real) {
    uniform(f) and uniform(g)
    implies
    uniform(compose(f, g))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let delta1: Real satisfy {
                delta1.is_positive and uniform_condition(f, delta1, eps)
            }
            let delta2: Real satisfy {
                delta2.is_positive and uniform_condition(g, delta2, delta1)
            }

            forall(x: Real, y: Real) {
                if x.is_close(y, delta2) {
                    g(x).is_close(g(y), delta1)
                    f(g(x)).is_close(f(g(y)), eps)
                    compose(f, g)(x).is_close(compose(f, g)(y), eps)
                }
            }

            delta2.is_positive and uniform_condition(compose(f, g), delta2, eps)
        }
    }
}

theorem rat_mul_uniform(r: Rat) {
    rat_uniform(compose(Real.from_rat, r.mul))
} by {
    let mul_r: Rat -> Real = compose(Real.from_rat, r.mul)
    forall(eps: Real) {
        if eps.is_positive {
            Real.0 < eps
            let reps1: Rat satisfy {
                Real.from_rat(reps1) < eps and reps1.is_positive
            }
            let reps2: Rat satisfy {
                reps2 < reps1 and reps2.is_positive
            }
            Rat.0 <= r.abs
            let delta: Rat satisfy {
                delta.is_positive and r.abs * delta < reps2
            }
            forall(r1: Rat, r2: Rat) {
                if r1.is_close(r2, delta) {
                    (r1 - r2).abs < delta
                    (r1 - r2).abs <= delta
                    (r1 - r2).abs * r.abs <= delta * r.abs
                    r.abs * (r1 - r2).abs <= r.abs * delta
                    (r * (r1 - r2)).abs <= r.abs * delta
                    (r * r1 - r * r2).abs <= r.abs * delta
                    r.abs * delta <= reps2
                    (r * r1 - r * r2).abs <= reps2
                    (r * r1 - r * r2).abs < reps1
                    Real.from_rat(r * r1).is_close(Real.from_rat(r * r2), Real.from_rat(reps1))
                    Real.from_rat(r * r1).is_close(Real.from_rat(r * r2), eps)
                    mul_r(r1).is_close(mul_r(r2), eps)
                }
            }
            delta.is_positive and rat_condition(mul_r, delta, eps)
        }
    }
    rat_uniform(mul_r)
}

theorem close_add(a: Real, b: Real, c: Real, eps: Real) {
    a.is_close(b, eps)
    implies
    (a + c).is_close(b + c, eps)
} by {
    (a - b).abs < eps
    (a + c - (c + b)).abs < eps
    (a + c - (b + c)).abs < eps
}

theorem add_real_uniform(x: Real) {
    uniform(x.add)
} by {
    forall(eps: Real) {
        if eps.is_positive {
            forall(a: Real, b: Real) {
                if a.is_close(b, eps) {
                    (x + a).is_close(x + b, eps)
                    x.add(a).is_close(x.add(b), eps)
                }
            }
            uniform_condition(x.add, eps, eps)
        }
    }
}

theorem neg_uniform {
    uniform(Real.neg)
} by {
    forall(eps: Real) {
        if eps.is_positive {
            forall(x: Real, y: Real) {
                if x.is_close(y, eps) {
                    (-x).is_close(-y, eps)
                    Real.neg(x).is_close(Real.neg(y), eps)
                }
            }
            uniform_condition(Real.neg, eps, eps)
        }
    }
}



define add_fns<T>(f: T -> Real, g: T -> Real, t: T) -> Real {
    f(t) + g(t)
}

theorem add_fns_uniform(f: Real -> Real, g: Real -> Real) {
    uniform(f) and uniform(g)
    implies
    uniform(add_fns(f, g))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and eps2 + eps2 < eps
            }
            let delta1: Real satisfy {
                delta1.is_positive and uniform_condition(f, delta1, eps2)
            }
            let delta2: Real satisfy {
                delta2.is_positive and uniform_condition(g, delta2, eps2)
            }
            let delta: Real satisfy {
                delta.is_positive and delta < delta1 and delta < delta2
            }

            forall(x: Real, y: Real) {
                if x.is_close(y, delta) {
                    x.is_close(y, delta1)
                    f(x).is_close(f(y), eps2)
                    x.is_close(y, delta2)
                    g(x).is_close(g(y), eps2)
                    (f(x) + g(x)).is_close(f(y) + g(y), eps2 + eps2)
                    (f(x) + g(x)).is_close(f(y) + g(y), eps)
                    add_fns(f, g, x).is_close(add_fns(f, g, y), eps)
                }
            }

            delta.is_positive and uniform_condition(add_fns(f, g), delta, eps)
        }
    }
}

// Equivalence classes between Cauchy sequences.
define seq_eq(a: Nat -> Rat, b: Nat -> Rat) -> Bool {
    converges(lift_seq(a)) and converges_to(lift_seq(b), limit_rat(a))
}

theorem seq_eq_symm(a: Nat -> Rat, b: Nat -> Rat) {
    seq_eq(a, b) implies seq_eq(b, a)
} by {
    converges_to(lift_seq(b), limit_rat(a))
    converges_to(lift_seq(b), limit_rat(b))
    limit_rat(b) = limit_rat(a)
    converges(lift_seq(a))
    converges_to(lift_seq(a), limit_rat(a))
    converges_to(lift_seq(a), limit_rat(b))
}

define add_rat_seq(a: Nat -> Rat, b: Nat -> Rat, n: Nat) -> Rat {
    a(n) + b(n)
}

theorem add_rat_seq_is_add(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b))
    implies
    converges_to(lift_seq(add_rat_seq(a, b)), limit_rat(a) + limit_rat(b))
} by {
    let seq: Nat -> Real = lift_seq(add_rat_seq(a, b))
    let target: Real = limit_rat(a) + limit_rat(b)
    forall(eps: Real) {
        if eps.is_positive {
            let delta: Real satisfy {
                delta.is_positive and delta + delta < eps
            }
            let n1: Nat satisfy {
                forall(i: Nat) {
                    n1 <= i implies lift_seq(a)(i).is_close(limit_rat(a), delta)
                }
            }
            let n2: Nat satisfy {
                forall(i: Nat) {
                    n2 <= i implies lift_seq(b)(i).is_close(limit_rat(b), delta)
                }
            }
            let n: Nat satisfy {
                n1 <= n and n2 <= n
            }
            forall(i: Nat) {
                if n <= i {
                    lift_seq(a)(i).is_close(limit_rat(a), delta)
                    lift_seq(b)(i).is_close(limit_rat(b), delta)
                    (lift_seq(a, i) + lift_seq(b, i)).is_close(limit_rat(a) + limit_rat(b), delta + delta)
                    seq(i).is_close(target, delta + delta)
                    seq(i).is_close(target, eps)
                }
            }
        }
    }
    converges_to(seq, target)
}

define mul_rat_seq(a: Nat -> Rat, b: Nat -> Rat, n: Nat) -> Rat {
    a(n) * b(n)
}

define neg_rat_seq(a: Nat -> Rat, n: Nat) -> Rat {
    -a(n)
}

theorem neg_is_close(x: Real, y: Real, eps: Real) {
    x.is_close(y, eps) implies
    (-x).is_close(-y, eps)
} by {
    (x - y).abs < eps
    (-x + y).abs < eps
}

theorem neg_seq_converges(a: Nat -> Rat) {
    converges(lift_seq(a)) implies
    converges_to(lift_seq(neg_rat_seq(a)), -limit_rat(a))
} by {
    let seq: Nat -> Real = lift_seq(neg_rat_seq(a))
    let target: Real = -limit_rat(a)
    forall(eps: Real) {
        if eps.is_positive {
            let delta: Real satisfy {
                delta.is_positive and delta < eps
            }
            let n1: Nat satisfy {
                forall(i: Nat) {
                    n1 <= i implies lift_seq(a)(i).is_close(limit_rat(a), delta)
                }
            }
            let n: Nat satisfy {
                n1 <= n
            }
            forall(i: Nat) {
                if n <= i {
                    lift_seq(a)(i).is_close(limit_rat(a), delta)
                    (-lift_seq(a, i)).is_close(-limit_rat(a), delta)
                    seq(i).is_close(target, delta)
                    seq(i).is_close(target, eps)
                }
            }
        }
    }
    converges_to(seq, target)
}

// Prove that convergent sequences can be bounded.
theorem converges_imp_bounded(a: Nat -> Rat) {
    converges(lift_seq(a))
    implies
    exists(b: Rat) {
        forall(i: Nat) {
            a(i) < b
        }
    }
} by {
    let eventual: Real satisfy {
        eventual_ub(lift_seq(a), eventual)
    }
    let n: Nat satisfy {
        forall(i: Nat) {
            n <= i implies lift_seq(a)(i) <= eventual
        }
    }
    let finite: Rat satisfy {
        forall(i: Nat) {
            i <= n implies a(i) < finite
        }
    }
    let bound: Rat satisfy {
        eventual < Real.from_rat(bound) and finite < bound
    }
    forall(i: Nat) {
        if n <= i {
            Real.from_rat(a(i)) <= eventual
            Real.from_rat(bound) > Real.from_rat(a(i))
            Real.from_rat(bound).gt_rat(a(i))
            a(i) < bound
        } else {
            i <= n
            a(i) < bound
        }
    }
}

// Prove that convergent sequences can have their absolute value bounded.
theorem converges_imp_abs_bounded(a: Nat -> Rat) {
    converges(lift_seq(a))
    implies
    exists(b: Rat) {
        forall(i: Nat) {
            a(i).abs < b
        }
    }
} by {
    let pos_bound: Rat satisfy {
        forall(i: Nat) {
            a(i) < pos_bound
        }
    }
    converges(lift_seq(neg_rat_seq(a)))
    let neg_bound: Rat satisfy {
        forall(i: Nat) {
            neg_rat_seq(a)(i) < neg_bound
        }
    }
    let bound: Rat satisfy {
        pos_bound < bound and neg_bound < bound
    }
    forall(i: Nat) {
        if a(i).is_negative {
            a(i).abs < bound
        } else {
            a(i).abs < bound
        }
    }
}

theorem diff_pos_imp_lt(a: Real, b: Real) {
    (b - a).is_positive implies a < b
} by {
    (b + -a).is_positive
    b + -a > Real.0
    Real.0 - -a < b
    Real.0 + a < b
}

theorem smaller_rat_eps(eps: Real) {
    eps.is_positive implies
    exists(reps: Rat) {
        reps.is_positive and Real.from_rat(reps) < eps
    }
} by {
    Real.0 < eps
}

// Prove that multiplying convergent sequences gives you a convergent sequence.
theorem mul_rat_seq_converges(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b))
    implies
    converges(lift_seq(mul_rat_seq(a, b)))
} by {
    let a_ub: Rat satisfy {
        forall(i: Nat) {
            a(i).abs < a_ub
        }
    }
    let b_ub: Rat satisfy {
        forall(i: Nat) {
            b(i).abs < b_ub
        }
    }
    let ub: Rat satisfy {
        a_ub < ub and b_ub < ub
    }
    ub.is_positive
    let seq: Nat -> Real = lift_seq(mul_rat_seq(a, b))
    forall(eps: Real) {
        if eps.is_positive {
            let reps: Rat satisfy {
                reps.is_positive and Real.from_rat(reps) < eps
            }
            let reps2: Rat = reps / (ub + ub)
            (ub + ub).is_positive
            reps2.is_positive
            let eps2: Real = Real.from_rat(reps2)
            eps2.is_positive
            let n_a: Nat satisfy {
                forall(i: Nat, j: Nat) {
                    n_a <= i and n_a <= j implies
                    lift_seq(a)(i).is_close(lift_seq(a)(j), eps2)
                }
            }
            let n_b: Nat satisfy {
                forall(i: Nat, j: Nat) {
                    n_b <= i and n_b <= j implies
                    lift_seq(b)(i).is_close(lift_seq(b)(j), eps2)
                }
            }
            let n: Nat satisfy {
                n_a <= n and n_b <= n
            }
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    n_a <= i
                    n_a <= j
                    lift_seq(a)(i).is_close(lift_seq(a)(j), eps2)
                    a(i).is_close(a(j), reps2)
                    n_b <= i
                    n_b <= j
                    lift_seq(b)(i).is_close(lift_seq(b)(j), eps2)
                    b(i).is_close(b(j), reps2)
                    (a(i) * b(i) - a(j) * b(j)).abs <= a(i).abs * (b(i) - b(j)).abs + b(j).abs * (a(i) - a(j)).abs
                    a(i).abs < ub
                    (b(i) - b(j)).abs < reps2
                    not a(i).abs.is_negative
                    not (b(i) - b(j)).abs.is_negative
                    a(i).abs * (b(i) - b(j)).abs < ub * reps2
                    b(j).abs < ub
                    (a(i) - a(j)).abs < reps2
                    not b(j).abs.is_negative
                    not (a(i) - a(j)).abs.is_negative
                    b(j).abs * (a(i) - a(j)).abs < ub * reps2
                    a(i).abs * (b(i) - b(j)).abs + b(j).abs * (a(i) - a(j)).abs < ub * reps2 + ub * reps2
                    (a(i) * b(i) - a(j) * b(j)).abs < ub * reps2 + ub * reps2
                    ub + ub != Rat.0
                    (ub + ub) * (reps / (ub + ub)) = reps
                    ub * reps2 + ub * reps2 = reps
                    (a(i) * b(i) - a(j) * b(j)).abs < reps
                    (a(i) * b(i)).is_close(a(j) * b(j), reps)
                    lift_seq(mul_rat_seq(a, b))(i).is_close(lift_seq(mul_rat_seq(a, b))(j), Real.from_rat(reps))
                    seq(i).is_close(seq(j), eps)
                }
            }
            cauchy_condition(seq, n, eps)
            cauchy_condition(lift_seq(mul_rat_seq(a, b)), n, eps)
        }
    }
}

define sub_rat_seq(a: Nat -> Rat, b: Nat -> Rat, n: Nat) -> Rat {
    a(n) - b(n)
}

theorem add_neg_is_sub(a: Nat -> Rat, b: Nat -> Rat) {
    add_rat_seq(a, neg_rat_seq(b)) = sub_rat_seq(a, b)
}

define const_rat_seq(a: Rat, n: Nat) -> Rat {
    a
}

theorem const_rat_converges_to_rat(a: Rat) {
    converges_to(lift_seq(const_rat_seq(a)), Real.from_rat(a))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            forall(i: Nat) {
                lift_seq(const_rat_seq(a))(i).is_close(Real.from_rat(a), eps)
            }
        }
    }
}

let zero_rat_seq: Nat -> Rat = const_rat_seq(Rat.0)

theorem zero_rat_seq_is_zero {
    converges_to(lift_seq(zero_rat_seq), Real.0)
}

theorem neg_is_zero_sub(a: Nat -> Rat) {
    neg_rat_seq(a) = sub_rat_seq(zero_rat_seq, a)
}

// Negating is well-defined with respect to seq_eq
theorem neg_rat_seq_well_def(a: Nat -> Rat, b: Nat -> Rat) {
    seq_eq(a, b) implies
    seq_eq(neg_rat_seq(a), neg_rat_seq(b))
} by {
    converges_to(lift_seq(neg_rat_seq(a)), -limit_rat(a))
    converges_to(lift_seq(neg_rat_seq(b)), -limit_rat(b))
    limit_rat(a) = limit_rat(b)
    converges(lift_seq(neg_rat_seq(a)))
    converges_to(lift_seq(neg_rat_seq(a)), -limit_rat(b))
    converges_to(lift_seq(neg_rat_seq(a)), limit(lift_seq(neg_rat_seq(a))))
    limit(lift_seq(neg_rat_seq(a))) = -limit_rat(b)
    converges_to(lift_seq(neg_rat_seq(b)), limit(lift_seq(neg_rat_seq(a))))
    converges_to(lift_seq(neg_rat_seq(b)), limit_rat(neg_rat_seq(a)))
}

// Addition is well-defined with respect to seq_eq
theorem add_rat_seq_well_def(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat, d: Nat -> Rat) {
    seq_eq(a, c) and seq_eq(b, d)
    implies
    seq_eq(add_rat_seq(a, b), add_rat_seq(c, d))
} by {
    converges_to(lift_seq(add_rat_seq(a, b)), limit_rat(a) + limit_rat(b))
    converges_to(lift_seq(add_rat_seq(c, d)), limit_rat(c) + limit_rat(d))
    limit_rat(a) = limit_rat(c)
    limit_rat(b) = limit_rat(d)
    limit_rat(a) + limit_rat(b) = limit_rat(c) + limit_rat(d)
    limit_rat(add_rat_seq(a, b)) = limit_rat(a) + limit_rat(b)
    limit_rat(add_rat_seq(c, d)) = limit_rat(c) + limit_rat(d)
}

theorem sub_rat_seq_is_sub(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b))
    implies
    converges_to(lift_seq(sub_rat_seq(a, b)), limit_rat(a) - limit_rat(b))
} by {
    converges_to(lift_seq(neg_rat_seq(b)), -limit_rat(b))
    converges(lift_seq(neg_rat_seq(b)))
    converges_to(lift_seq(neg_rat_seq(b)), limit(lift_seq(neg_rat_seq(b))))
    limit(lift_seq(neg_rat_seq(b))) = -limit_rat(b)
    converges_to(lift_seq(add_rat_seq(a, neg_rat_seq(b))), limit_rat(a) + limit_rat(neg_rat_seq(b)))
    converges_to(lift_seq(add_rat_seq(a, neg_rat_seq(b))), limit_rat(a) + -limit_rat(b))
    converges_to(lift_seq(add_rat_seq(a, neg_rat_seq(b))), limit_rat(a) - limit_rat(b))
    add_rat_seq(a, neg_rat_seq(b)) = sub_rat_seq(a, b)
}

// Subtraction is well-defined with respect to seq_eq
theorem sub_rat_seq_well_def(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat, d: Nat -> Rat) {
    seq_eq(a, c) and seq_eq(b, d)
    implies
    seq_eq(sub_rat_seq(a, b), sub_rat_seq(c, d))
} by {
    converges_to(lift_seq(sub_rat_seq(a, b)), limit_rat(a) - limit_rat(b))
    converges_to(lift_seq(sub_rat_seq(c, d)), limit_rat(c) - limit_rat(d))
    limit_rat(a) = limit_rat(c)
    limit_rat(b) = limit_rat(d)
    limit_rat(a) - limit_rat(b) = limit_rat(c) - limit_rat(d)
    limit_rat(sub_rat_seq(a, b)) = limit_rat(a) - limit_rat(b)
    limit_rat(sub_rat_seq(c, d)) = limit_rat(c) - limit_rat(d)
}

theorem sub_zero_imp_eq(x: Real, y: Real) {
    x - y = Real.0 implies x = y
}

// If two convergent sequences subtract to a zero-equivalent sequence, they are equal.
theorem sub_eq_zero_imp_eq(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b)) and seq_eq(sub_rat_seq(a, b), zero_rat_seq) implies
    seq_eq(a, b)
} by {
    limit_rat(sub_rat_seq(a, b)) = limit_rat(zero_rat_seq)
    limit_rat(sub_rat_seq(a, b)) = limit_rat(a) - limit_rat(b)
    limit_rat(a) - limit_rat(b) = limit_rat(zero_rat_seq)
    limit_rat(a) - limit_rat(b) = Real.0
    limit_rat(a) = limit_rat(b)
}

theorem self_eq(a: Nat -> Rat) {
    converges(lift_seq(a)) implies
    seq_eq(a, a)
} by {
    converges_to(lift_seq(a), limit_rat(a))
    converges_to(lift_seq(a), limit(lift_seq(a)))
    limit(lift_seq(a)) = limit_rat(a)
}

// Addition of sequences is commutative because the sequences themselves are identical
theorem add_rat_seq_comm(a: Nat -> Rat, b: Nat -> Rat) {
    add_rat_seq(a, b) = add_rat_seq(b, a)
}

// Multiplication of sequences is commutative because the sequences themselves are identical
theorem mul_rat_seq_comm(a: Nat -> Rat, b: Nat -> Rat) {
    mul_rat_seq(a, b) = mul_rat_seq(b, a)
}

// Right-distributive property follows from sequence identity
theorem add_rat_seq_distributes_right(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    mul_rat_seq(a, add_rat_seq(b, c)) = add_rat_seq(mul_rat_seq(a, b), mul_rat_seq(a, c))
}

theorem add_rat_seq_distributes_left(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    mul_rat_seq(add_rat_seq(b, c), a) = add_rat_seq(mul_rat_seq(b, a), mul_rat_seq(c, a))
}

theorem sub_rat_seq_distributes_right(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    mul_rat_seq(a, sub_rat_seq(b, c)) = sub_rat_seq(mul_rat_seq(a, b), mul_rat_seq(a, c))
}

theorem sub_rat_seq_distributes_left(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    mul_rat_seq(sub_rat_seq(b, c), a) = sub_rat_seq(mul_rat_seq(b, a), mul_rat_seq(c, a))
}

theorem converges_to_zero_imp_seq_eq_zero(a: Nat -> Rat) {
    converges_to(lift_seq(a), Real.0)
    implies
    seq_eq(a, zero_rat_seq)
} by {
    converges(lift_seq(a))
    converges_to(lift_seq(a), limit(lift_seq(a)))
    limit(lift_seq(a)) = Real.0
    converges_to(lift_seq(zero_rat_seq), Real.0)
    limit(lift_seq(zero_rat_seq)) = Real.0
    seq_eq(a, zero_rat_seq)
}

theorem seq_eq_zero_imp_converges_to_zero(a: Nat -> Rat) {
    seq_eq(a, zero_rat_seq)
    implies
    converges_to(lift_seq(a), Real.0)
} by {
    converges(lift_seq(a))
    converges_to(lift_seq(a), limit(lift_seq(a)))
    limit(lift_seq(a)) = Real.0
    converges_to(lift_seq(zero_rat_seq), Real.0)
    limit(lift_seq(zero_rat_seq)) = Real.0
}

// Multiplying by a null sequence gives a null sequence.
theorem mul_zero_rat_seq(a: Nat -> Rat, z: Nat -> Rat) {
    converges(lift_seq(a)) and seq_eq(z, zero_rat_seq)
    implies
    seq_eq(mul_rat_seq(a, z), zero_rat_seq)
} by {
    let ub: Rat satisfy {
        forall(i: Nat) {
            a(i).abs < ub
        }
    }
    let mul_seq: Nat -> Real = lift_seq(mul_rat_seq(a, z))
    forall(eps: Real) {
        if eps.is_positive {
            let reps: Rat satisfy {
                reps.is_positive and Real.from_rat(reps) < eps
            }
            let reps2: Rat = reps / ub
            ub.is_positive
            reps2.is_positive
            let eps2: Real = Real.from_rat(reps2)
            eps2.is_positive
            converges_to(lift_seq(z), Real.0)
            let n: Nat satisfy {
                forall(i: Nat) {
                    n <= i implies lift_seq(z)(i).is_close(Real.0, eps2)
                }
            }
            forall(i: Nat) {
                if n <= i {
                    a(i).abs < ub
                    lift_seq(z)(i).is_close(Real.0, eps2)
                    (lift_seq(z, i) + Real.0).is_close(Real.0, eps2)
                    lift_seq(z, i).abs < eps2
                    Real.from_rat(z(i).abs) < Real.from_rat(reps2)
                    z(i).abs < reps2
                    (a(i) * z(i)).abs < ub * reps2
                    ub * reps2 = reps
                    (a(i) * z(i)).abs < reps
                    mul_rat_seq(a, z)(i).abs < reps
                    Real.from_rat(mul_rat_seq(a, z)(i).abs) < Real.from_rat(reps)
                    lift_seq(mul_rat_seq(a, z))(i).abs < eps
                    mul_seq(i).is_close(Real.0, eps)
                }
            }
        }
    }
    converges_to(mul_seq, Real.0)
    converges_to(lift_seq(mul_rat_seq(a, z)), Real.0)
}

theorem sub_rat_eq_imp_sub_zero(a: Nat -> Rat, b: Nat -> Rat) {
    seq_eq(a, b) implies
    seq_eq(sub_rat_seq(a, b), zero_rat_seq)
} by {
    converges(lift_seq(a))
    converges(lift_seq(b))
    converges_to(lift_seq(sub_rat_seq(a, b)), limit_rat(a) - limit_rat(b))
    converges_to(lift_seq(b), limit(lift_seq(b)))
    converges_to(lift_seq(b), limit_rat(a))
    limit(lift_seq(b)) = limit_rat(a)
    converges_to(lift_seq(sub_rat_seq(a, b)), Real.0)
    converges_to(lift_seq(zero_rat_seq), Real.0)
    limit(lift_seq(sub_rat_seq(a, b))) = Real.0
    limit(lift_seq(zero_rat_seq)) = Real.0
}

theorem sub_rat_sub_zero_imp_eq(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b)) and seq_eq(sub_rat_seq(a, b), zero_rat_seq)
    implies
    seq_eq(a, b)
} by {
    converges_to(lift_seq(sub_rat_seq(a, b)), Real.0)
    converges_to(lift_seq(zero_rat_seq), Real.0)
    limit(lift_seq(sub_rat_seq(a, b))) = Real.0
    limit(lift_seq(zero_rat_seq)) = Real.0
    limit_rat(sub_rat_seq(a, b)) = Real.0
    limit_rat(a) - limit_rat(b) = Real.0
    limit_rat(a) = limit_rat(b)
}

// Prove that multiplying by a single convergent sequence is well-defined
theorem mul_right_well_def(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    seq_eq(b, c) and converges(lift_seq(a))
    implies
    seq_eq(mul_rat_seq(a, b), mul_rat_seq(a, c))
} by {
    let diff: Nat -> Rat = sub_rat_seq(mul_rat_seq(a, b), mul_rat_seq(a, c))
    converges(lift_seq(diff))
    diff = mul_rat_seq(a, sub_rat_seq(b, c))
    seq_eq(diff, mul_rat_seq(a, sub_rat_seq(b, c)))
    seq_eq(sub_rat_seq(b, c), zero_rat_seq)
    seq_eq(diff, zero_rat_seq)
    seq_eq(sub_rat_seq(mul_rat_seq(a, b), mul_rat_seq(a, c)), zero_rat_seq)
    converges_to(lift_seq(c), limit_rat(b))
    converges(lift_seq(c))
    converges(lift_seq(b))
    converges(lift_seq(mul_rat_seq(a, b)))
}

theorem mul_left_well_def(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    seq_eq(a, b) and converges(lift_seq(c))
    implies
    seq_eq(mul_rat_seq(a, c), mul_rat_seq(b, c))
} by {
    seq_eq(mul_rat_seq(c, a), mul_rat_seq(c, b))
    mul_rat_seq(c, a) = mul_rat_seq(a, c)
    mul_rat_seq(c, b) = mul_rat_seq(b, c)
}

theorem seq_eq_trans(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    seq_eq(a, b) and seq_eq(b, c)
    implies
    seq_eq(a, c)
} by {
    converges(lift_seq(a))
    converges(lift_seq(b))
    converges(lift_seq(c))
    converges_to(lift_seq(a), limit_rat(a))
    converges_to(lift_seq(b), limit_rat(b))
    converges_to(lift_seq(c), limit_rat(c))
    limit_rat(a) = limit_rat(b)
    limit_rat(b) = limit_rat(c)
    limit_rat(a) = limit_rat(c)
}

// Prove that multiplying equivalent sequences gives equivalent things.
theorem mul_rat_seq_eq(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat, d: Nat -> Rat) {
    seq_eq(a, c) and seq_eq(b, d)
    implies
    seq_eq(mul_rat_seq(a, b), mul_rat_seq(c, d))
} by {
    seq_eq(mul_rat_seq(a, b), mul_rat_seq(c, b))
    seq_eq(mul_rat_seq(c, b), mul_rat_seq(c, d))
}

// Historically we proved some theorems around continuity and 2d continuity here.
// But this might not be the best order to prove things in.
// Same for the uniform continuity theorems.
define continuous2_condition(f: (Real, Real) -> Real, x: Real, y: Real, delta: Real, eps: Real) -> Bool {
    forall(x1: Real, y1: Real) {
        x1.is_close(x, delta) and y1.is_close(y, delta) implies
        f(x1, y1).is_close(f(x, y), eps)
    }
}

define continuous2_at(f: (Real, Real) -> Real, x: Real, y: Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(delta: Real) {
            delta.is_positive and
            continuous2_condition(f, x, y, delta, eps)
        }
    }
}

define continuous2(f: (Real, Real) -> Real) -> Bool {
    forall(x: Real, y: Real) {
        continuous2_at(f, x, y)
    }
}

// Addition is continuous.
theorem add_continuous2 {
    continuous2(Real.add)
} by {
    forall(x: Real, y: Real) {
        forall(eps: Real) {
            if eps.is_positive {
                let delta: Real satisfy {
                    delta.is_positive and delta + delta < eps
                }
                forall(x1: Real, y1: Real) {
                    if x1.is_close(x, delta) and y1.is_close(y, delta) {
                        Real.add(x1, y1).is_close(Real.add(x, y), eps)
                    }
                }
                continuous2_condition(Real.add, x, y, delta, eps)
                delta.is_positive and continuous2_condition(Real.add, x, y, delta, eps)
            }
        }
        continuous2_at(Real.add, x, y)
    }
}

define continuous_condition(f: Real -> Real, x: Real, delta: Real, eps: Real) -> Bool {
    forall(x1: Real) {
        x1.is_close(x, delta) implies
        f(x1).is_close(f(x), eps)
    }
}

define continuous_at(f: Real -> Real, x: Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(delta: Real) {
            delta.is_positive and continuous_condition(f, x, delta, eps)
        }
    }
}

define continuous(f: Real -> Real) -> Bool {
    forall(x: Real) {
        continuous_at(f, x)
    }
}

theorem uniform_imp_continuous(f: Real -> Real) {
    uniform(f)
    implies
    continuous(f)
} by {
    forall(x: Real) {
        forall(eps: Real) {
            if eps.is_positive {
                let delta: Real satisfy {
                    delta.is_positive and uniform_condition(f, delta, eps)
                }
                forall(x1: Real) {
                    if x1.is_close(x, delta) {
                        f(x1).is_close(f(x), eps)
                    }
                }
                continuous_condition(f, x, delta, eps)
                delta.is_positive and continuous_condition(f, x, delta, eps)
            }
        }
        continuous_at(f, x)
    }
}

class Real {
    define mul(self, other: Real) -> Real {
        limit_rat(mul_rat_seq(rat_seq(self), rat_seq(other)))
    }
}

theorem mul_comm(x: Real, y: Real) {
    x * y = y * x
} by {
    x * y = limit_rat(mul_rat_seq(rat_seq(x), rat_seq(y)))
    y * x = limit_rat(mul_rat_seq(rat_seq(y), rat_seq(x)))
    mul_rat_seq(rat_seq(x), rat_seq(y)) = mul_rat_seq(rat_seq(y), rat_seq(x))
}

theorem mul3_as_seq(x: Real, y: Real, z: Real) {
    x * y * z = limit_rat(mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z)))
} by {
    x * y * z = limit_rat(mul_rat_seq(rat_seq(x * y), rat_seq(z)))
    seq_eq(rat_seq(x * y), mul_rat_seq(rat_seq(x), rat_seq(y)))
    seq_eq(mul_rat_seq(rat_seq(x * y), rat_seq(z)), mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z)))
    converges(lift_seq(mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z))))
    converges_to(lift_seq(mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z))), x * y * z)
    limit(lift_seq(mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z)))) = x * y * z
}

theorem mul_seq_assoc(a: Nat -> Rat, b: Nat -> Rat, c: Nat -> Rat) {
    mul_rat_seq(mul_rat_seq(a, b), c) = mul_rat_seq(a, mul_rat_seq(b, c))
}

theorem mul_assoc(x: Real, y: Real, z: Real) {
    x * (y * z) = (x * y) * z
} by {
    mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z)) = mul_rat_seq(rat_seq(x), mul_rat_seq(rat_seq(y), rat_seq(z)))
    (x * y) * z = limit_rat(mul_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), rat_seq(z)))
    (x * y) * z = limit_rat(mul_rat_seq(rat_seq(x), mul_rat_seq(rat_seq(y), rat_seq(z))))
    (y * z) * x = limit_rat(mul_rat_seq(mul_rat_seq(rat_seq(y), rat_seq(z)), rat_seq(x)))
    mul_rat_seq(rat_seq(x), mul_rat_seq(rat_seq(y), rat_seq(z))) = mul_rat_seq(mul_rat_seq(rat_seq(y), rat_seq(z)), rat_seq(x))
    x * y * z = y * z * x
}

theorem limit_rat_rat_seq(x: Real) {
    x = limit_rat(rat_seq(x))
}

theorem limit_definition_of_add(x: Real, y: Real) {
    x + y = limit_rat(add_rat_seq(rat_seq(x), rat_seq(y)))
} by {
    converges_to(lift_seq(rat_seq(x)), x)
    converges_to(lift_seq(rat_seq(y)), y)
    converges_to(lift_seq(add_rat_seq(rat_seq(x), rat_seq(y))), limit_rat(rat_seq(x)) + limit_rat(rat_seq(y)))
    converges_to(lift_seq(add_rat_seq(rat_seq(x), rat_seq(y))), limit_rat(rat_seq(x)) + y)
    converges_to(lift_seq(add_rat_seq(rat_seq(x), rat_seq(y))), x + y)
}

theorem seq_eq_rat_seq_limit(a: Nat -> Rat) {
    converges(lift_seq(a)) implies
    seq_eq(a, rat_seq(limit_rat(a)))
} by {
    converges_to(lift_seq(a), limit_rat(a))
    converges_to(lift_seq(rat_seq(limit_rat(a))), limit_rat(a))
    limit(lift_seq(a)) = limit(lift_seq(rat_seq(limit_rat(a))))
    converges_to(lift_seq(rat_seq(limit_rat(a))), limit(lift_seq(rat_seq(limit_rat(a)))))
}

theorem seq_eq_imp_limit_rat_eq(a: Nat -> Rat, b: Nat -> Rat) {
    seq_eq(a, b) implies
    limit_rat(a) = limit_rat(b)
}

theorem limit_rat_add(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b))
    implies
    limit_rat(add_rat_seq(a, b)) = limit_rat(a) + limit_rat(b)
}

theorem mul_distrib_right(x: Real, y: Real, z: Real) {
    x * (y + z) = x * y + x * z
} by {
    // Reduce the lhs to sequence form.
    y + z = limit_rat(add_rat_seq(rat_seq(y), rat_seq(z)))
    x * (y + z) = limit_rat(mul_rat_seq(rat_seq(x), rat_seq(y + z)))
    let syz: Nat -> Rat = add_rat_seq(rat_seq(y), rat_seq(z))
    y + z = limit_rat(syz)
    converges(lift_seq(add_rat_seq(rat_seq(y), rat_seq(z))))
    converges(lift_seq(syz))
    seq_eq(syz, rat_seq(y + z))
    seq_eq(add_rat_seq(rat_seq(y), rat_seq(z)), rat_seq(y + z))
    seq_eq(rat_seq(y + z), add_rat_seq(rat_seq(y), rat_seq(z)))
    seq_eq(mul_rat_seq(rat_seq(x), add_rat_seq(rat_seq(y), rat_seq(z))), mul_rat_seq(rat_seq(x), rat_seq(y + z)))
    limit_rat(mul_rat_seq(rat_seq(x), add_rat_seq(rat_seq(y), rat_seq(z)))) = limit_rat(mul_rat_seq(rat_seq(x), rat_seq(y + z)))
    x * (y + z) = limit_rat(mul_rat_seq(rat_seq(x), add_rat_seq(rat_seq(y), rat_seq(z))))

    // Reduce the rhs to sequence form.
    x * y = limit_rat(mul_rat_seq(rat_seq(x), rat_seq(y)))
    x * z = limit_rat(mul_rat_seq(rat_seq(x), rat_seq(z)))
    let s1: Nat -> Rat = mul_rat_seq(rat_seq(x), rat_seq(y))
    let s2: Nat -> Rat = mul_rat_seq(rat_seq(x), rat_seq(z))
    x * y = limit_rat(s1)
    x * z = limit_rat(s2)
    converges(lift_seq(s1))
    converges(lift_seq(s2))
    limit_rat(s1) + limit_rat(s2) = limit_rat(add_rat_seq(s1, s2))
    x * y + x * z = limit_rat(add_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), mul_rat_seq(rat_seq(x), rat_seq(z))))

    // Now observe that the sequences themselves are equal.
    mul_rat_seq(rat_seq(x), add_rat_seq(rat_seq(y), rat_seq(z))) = add_rat_seq(mul_rat_seq(rat_seq(x), rat_seq(y)), mul_rat_seq(rat_seq(x), rat_seq(z)))
}

theorem mul_distrib_left(x: Real, y: Real, z: Real) {
    (x + y) * z = x * z + y * z
}

theorem limit_rat_mul_rat_seq(a: Nat -> Rat, b: Nat -> Rat) {
    converges(lift_seq(a)) and converges(lift_seq(b))
    implies
    limit_rat(mul_rat_seq(a, b)) = limit_rat(a) * limit_rat(b)
} by {
    converges_to(lift_seq(mul_rat_seq(a, b)), limit_rat(a) * limit_rat(b))
    converges_to(lift_seq(mul_rat_seq(a, b)), limit(lift_seq(mul_rat_seq(a, b))))
    limit(lift_seq(mul_rat_seq(a, b))) = limit_rat(a) * limit_rat(b)
}

theorem limit_rat_const_rat_seq(r: Rat) {
    limit_rat(const_rat_seq(r)) = Real.from_rat(r)
} by {
    converges_to(lift_seq(const_rat_seq(r)), limit_rat(rat_seq(Real.from_rat(r))))
    seq_eq(rat_seq(Real.from_rat(r)), const_rat_seq(r))
    limit_rat(rat_seq(Real.from_rat(r))) = limit_rat(const_rat_seq(r))
}

theorem mul_one_right(x: Real) {
    x * Real.1 = x
} by {
    converges(lift_seq(const_rat_seq(Rat.1)))
    limit_rat(rat_seq(x)) * limit_rat(const_rat_seq(Rat.1)) = limit_rat(mul_rat_seq(rat_seq(x), const_rat_seq(Rat.1)))
    mul_rat_seq(rat_seq(x), const_rat_seq(Rat.1)) = rat_seq(x)
    limit_rat(rat_seq(x)) = x
    x * limit_rat(const_rat_seq(Rat.1)) = x
    limit_rat(const_rat_seq(Rat.1)) = Real.from_rat(Rat.1)
}

theorem mul_one_left(x: Real) {
    Real.1 * x = x
}

theorem mul_zero_right(x: Real) {
    x * Real.0 = Real.0
} by {
    limit_rat(rat_seq(x)) * limit_rat(zero_rat_seq) = limit_rat(mul_rat_seq(rat_seq(x), zero_rat_seq))
    mul_rat_seq(rat_seq(x), zero_rat_seq) = zero_rat_seq
}

theorem mul_zero_left(x: Real) {
    Real.0 * x = Real.0
}

theorem mul_neg_one_left(x: Real) {
    -Real.1 * x = -x
} by {
    (Real.1 + -Real.1) * x = Real.0
    Real.1 * x + -Real.1 * x = Real.0
    x + -Real.1 * x = Real.0
}

theorem mul_neg_one_right(x: Real) {
    x * -Real.1 = -x
}

theorem mul_neg_left(x: Real, y: Real) {
    -x * y = -(x * y)
}

theorem mul_neg_right(x: Real, y: Real) {
    x * -y = -(x * y)
}

theorem mul_sub_distrib_right(x: Real, y: Real, z: Real) {
    x * (y - z) = x * y - x * z
}

theorem mul_sub_distrib_left(x: Real, y: Real, z: Real) {
    (x - y) * z = x * z - y * z
}

theorem real_lte_imp_rat_lte(p: Rat, q: Rat) {
    Real.from_rat(p) <= Real.from_rat(q) implies
    p <= q
}

theorem pos_lte_imp_pos(x: Real, y: Real) {
    x.is_positive and x <= y implies
    y.is_positive
}

theorem mul_pos_pos(x: Real, y: Real) {
    x.is_positive and y.is_positive
    implies
    (x * y).is_positive
} by {
    let x_lb: Rat satisfy {
        x_lb.is_positive and Real.from_rat(x_lb) < x
    }
    eventual_lb(lift_seq(rat_seq(x)), Real.from_rat(x_lb))
    let nx: Nat satisfy {
        forall(i: Nat) {
            nx <= i implies
            Real.from_rat(x_lb) <= lift_seq(rat_seq(x))(i)
        }
    }
    let y_lb: Rat satisfy {
        y_lb.is_positive and Real.from_rat(y_lb) < y
    }
    eventual_lb(lift_seq(rat_seq(y)), Real.from_rat(y_lb))
    let ny: Nat satisfy {
        forall(i: Nat) {
            ny <= i implies
            Real.from_rat(y_lb) <= lift_seq(rat_seq(y))(i)
        }
    }
    let n: Nat satisfy {
        nx <= n and ny <= n
    }
    forall(i: Nat) {
        if n <= i {
            nx <= i
            Real.from_rat(x_lb) <= lift_seq(rat_seq(x))(i)
            Real.from_rat(x_lb) <= Real.from_rat(rat_seq(x)(i))
            x_lb <= rat_seq(x)(i)
            ny <= i
            Real.from_rat(y_lb) <= lift_seq(rat_seq(y))(i)
            y_lb <= rat_seq(y)(i)
            x_lb * y_lb <= rat_seq(x)(i) * rat_seq(y)(i)
            x_lb * y_lb <= mul_rat_seq(rat_seq(x), rat_seq(y))(i)
            Real.from_rat(x_lb * y_lb) <= lift_seq(mul_rat_seq(rat_seq(x), rat_seq(y)))(i)
        }
    }
    eventual_lb(lift_seq(mul_rat_seq(rat_seq(x), rat_seq(y))), Real.from_rat(x_lb * y_lb))
    Real.from_rat(x_lb * y_lb) <= limit_rat(mul_rat_seq(rat_seq(x), rat_seq(y)))
    Real.from_rat(x_lb * y_lb) <= x * y
    (x_lb * y_lb).is_positive
    Real.from_rat(x_lb * y_lb).is_positive
}

theorem mul_neg_pos(x: Real, y: Real) {
    x.is_negative and y.is_positive
    implies
    (x * y).is_negative
}

theorem mul_pos_neg(x: Real, y: Real) {
    x.is_positive and y.is_negative
    implies
    (x * y).is_negative
}

theorem mul_neg_neg(x: Real, y: Real) {
    x.is_negative and y.is_negative
    implies
    (x * y).is_positive
}

theorem mul_nonneg_nonneg(x: Real, y: Real) {
    not x.is_negative and not y.is_negative
    implies
    not (x * y).is_negative
} by {
    if x = Real.0 {
        x * y = Real.0
        not (x * y).is_negative
    } else {
        x.is_positive
        if y = Real.0 {
            x * y = Real.0
            not (x * y).is_negative
        } else {
            (x * y).is_positive
            not (x * y).is_negative
        }
    }
}

theorem square_nonneg(x: Real) {
    x * x >= Real.0
} by {
    if x = Real.0 {
        x * x = Real.0
        x * x >= Real.0
    } else {
        if x.is_positive {
            x.is_positive
            (x * x).is_positive
            (x * x) > Real.0
            (x * x) >= Real.0
        } else {
            x.is_negative
            (x * x).is_positive
            (x * x) > Real.0
            (x * x) >= Real.0
        }
    }
}

theorem lt_mul_pos_right(x: Real, y: Real, z: Real) {
    z.is_positive and x < y implies
    x * z < y * z
}

theorem lte_mul_nonneg_right(x: Real, y: Real, z: Real) {
    not z.is_negative and x <= y implies
    x * z <= y * z
} by {
    if z = Real.0 {
        x * z = Real.0
        y * z = Real.0
        x * z = y * z
        x * z <= y * z
    } else {
        z.is_positive
        if x = y {
            x * z = y * z
            x * z <= y * z
        } else {
            x < y
            x * z < y * z
            x * z <= y * z
        }
    }
}

theorem lt_mul_neg_right(x: Real, y: Real, z: Real) {
    z.is_negative and x < y implies
    y * z < x * z
} by {
    not y < x
    y != x
    x - y != Real.0
    (x - y).is_negative
    ((x - y) * z).is_positive
}

theorem add_neg_neg(x: Real, y: Real) {
    x.is_negative and y.is_negative implies (x + y).is_negative
}

theorem zero_lte_imp_non_neg(x: Real) {
    Real.0 <= x implies not x.is_negative
}

theorem non_neg_imp_zero_lte(x: Real) {
    not x.is_negative implies Real.0 <= x
}

from monoid import AddComm, MulComm

instance Real: AddComm {
    let zero: Real = Real.0
    let add: (Real, Real) -> Real = Real.add
}

instance Real: MulComm {
    let one: Real = Real.1
    let mul: (Real, Real) -> Real = Real.mul
}
