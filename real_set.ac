from nat import Nat
from rat import Rat
from real_base import is_cut, is_lower, is_greatest, has_greatest, is_dedekind_cut
from real_ring import Real, converges, converges_to, limit

// This file proves theorems about sets of real numbers.

class Real {
    // Placeholder to let other modules import Real from here.
}

// Not strict.
define is_upper_bound(s: Real -> Bool, x: Real) -> Bool {
    forall(y: Real) {
        s(y) implies y <= x
    }
}

define is_least_upper_bound(s: Real -> Bool, x: Real) -> Bool {
    is_upper_bound(s, x) and
    forall(y: Real) {
        is_upper_bound(s, y) implies x <= y
    }
}

define is_nonempty(s: Real -> Bool) -> Bool {
    exists(x: Real) {
        s(x)
    }
}

// The supremum condition on s is that it's nonempty, and has
// an upper bound.
// sup_cut is the Dedekind cut that will be the supremum of s.
// First we define it, then we prove that it is a Dedekind cut.
define sup_cut(s: Real -> Bool, r: Rat) -> Bool {
    not is_upper_bound(s, Real.from_rat(r))
} 

theorem sup_cut_is_cut(s: Real -> Bool, ub: Real) {
    is_nonempty(s) and is_upper_bound(s, ub)
    implies
    is_cut(sup_cut(s))
} by {
    let x: Real satisfy {
        s(x)
    }
    
    let r1: Rat satisfy {
        Real.from_rat(r1) < x
    }
    
    not is_upper_bound(s, Real.from_rat(r1))
    sup_cut(s, r1)
    
    let r2: Rat satisfy {
        Real.from_rat(r2) > ub
    }
    
    // Show that r2 is an upper bound of s
    forall(y: Real) {
        if s(y) {
            y <= ub
            ub < Real.from_rat(r2)
            y < Real.from_rat(r2)
            y <= Real.from_rat(r2)
        }
    }
    is_upper_bound(s, Real.from_rat(r2))
    not sup_cut(s, r2)
}

theorem sup_cut_is_lower(s: Real -> Bool, ub: Real) {
    is_nonempty(s) and is_upper_bound(s, ub)
    implies
    is_lower(sup_cut(s))
} by {
    forall(x: Rat, y: Rat) {
        if sup_cut(s, y) and x < y {
            let z: Real satisfy {
                s(z) and z > Real.from_rat(y)
            }      
            z > Real.from_rat(x)            
            not is_upper_bound(s, Real.from_rat(x))
            sup_cut(s, x)
        }
    }
}
 
// theorem ub_imp_lub(s: Real -> Bool, x: Real) {
//     is_upper_bound(s, x) implies exists(y: Real) {
//         is_least_upper_bound(s, y)
//     }
// }